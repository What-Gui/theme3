<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="Zero knowledge proofs The notion of proof is central to so many fields. In mathematics, we want to prove that a certain assertion is correct. In other sciences, we often want to accumulate a preponderance of evidence (or statistical significance) to reject certain hypotheses. In criminal law the prosecution famously needs to prove its case &ldquo;beyond a reasonable doubt&rdquo;. Cryptography turns out to give some new twists on this ancient notion.\n">
<title>Zero Knowledge proofs</title>

<link rel='canonical' href='http://localhost:1313/p/zero-knowledge-proofs/'>

<link rel="stylesheet" href="/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css"><meta property='og:title' content="Zero Knowledge proofs">
<meta property='og:description' content="Zero knowledge proofs The notion of proof is central to so many fields. In mathematics, we want to prove that a certain assertion is correct. In other sciences, we often want to accumulate a preponderance of evidence (or statistical significance) to reject certain hypotheses. In criminal law the prosecution famously needs to prove its case &ldquo;beyond a reasonable doubt&rdquo;. Cryptography turns out to give some new twists on this ancient notion.\n">
<meta property='og:url' content='http://localhost:1313/p/zero-knowledge-proofs/'>
<meta property='og:site_name' content='Example Site'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' />
<meta name="twitter:title" content="Zero Knowledge proofs">
<meta name="twitter:description" content="Zero knowledge proofs The notion of proof is central to so many fields. In mathematics, we want to prove that a certain assertion is correct. In other sciences, we often want to accumulate a preponderance of evidence (or statistical significance) to reject certain hypotheses. In criminal law the prosecution famously needs to prove its case &ldquo;beyond a reasonable doubt&rdquo;. Cryptography turns out to give some new twists on this ancient notion.\n">
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true}, 
                {left: "$", right: "$", display: false}  
            ]
        });
    });
</script>
<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
    };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu13739649187745961479.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">üç•</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Example Site</a></h1>
            <h2 class="site-description">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="http://localhost:1313/" selected>English</option>
                                
                                    <option value="http://localhost:1313/zh-cn/" >‰∏≠Êñá</option>
                                
                                    <option value="http://localhost:1313/ar/" >ÿπÿ±ÿ®Ÿä</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#applications-for-zero-knowledge-proofs">Applications for zero knowledge proofs.</a>
      <ol>
        <li><a href="#nuclear-disarmament">Nuclear disarmament</a></li>
        <li><a href="#voting">Voting</a></li>
        <li><a href="#more-applications">More applications</a></li>
      </ol>
    </li>
    <li><a href="#defining-and-constructing-zero-knowledge-proofs">Defining and constructing zero knowledge proofs</a></li>
  </ol>

  <ol>
    <li><a href="#defining-zero-knowledge">Defining zero knowledge</a></li>
  </ol>

  <ol>
    <li><a href="#zero-knowledge-proof-for-hamiltonicity">Zero knowledge proof for Hamiltonicity.</a></li>
  </ol>

  <ol>
    <li>
      <ol>
        <li><a href="#why-is-this-interesting">Why is this interesting?</a></li>
      </ol>
    </li>
    <li><a href="#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures">Parallel repetition and turning zero knowledge proofs to signatures.</a>
      <ol>
        <li><a href="#bonus-features-of-zero-knowledge">&ldquo;Bonus features&rdquo; of zero knowledge</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/zero-knowledge-proofs/">Zero Knowledge proofs</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    30 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="zero-knowledge-proofs">Zero knowledge proofs
</h1><p>The notion of <em>proof</em> is central to so many fields.
In mathematics, we want to prove that a certain assertion is correct.
In other sciences, we often want to accumulate a preponderance of evidence (or statistical significance) to reject certain hypotheses.
In criminal law the prosecution famously needs to prove its case &ldquo;beyond a reasonable doubt&rdquo;.
Cryptography turns out to give some new twists on this ancient notion.</p>
<p>Typically a proof that some assertion X is true, also reveals some information about <em>why</em> X is true.
When Hercule Poirot proves that Norman Gale killed Madame Giselle he does so by showing <em>how</em> Gale committed the murder by dressing up as a flight attendant and stabbing Madame Gisselle with a poisoned dart.
Could Hercule convince us beyond a reasonable doubt that Gale did the crime without giving any information on <em>how</em> the crime was committed?
Can the Russians prove to the U.S. that a sealed box contains an authentic nuclear warhead without revealing anything about its design?
Can I prove to you that the number $m=385,608,108,395,369,363,400,501,273,594,475,104,405,448,848,047,$$062,278,473,983$ has a prime factor whose last digit is $7$ without giving you any information about $m$&rsquo;s prime factors?
We won&rsquo;t answer the first question, but will show some insights on the latter two.^[In case you are curious, the factors of $m$ are $1,172,192,558,529,627,184,841,954,822,099$ and $328,963,108,995,562,790,517,498,071,717$.]</p>
<p><em>Zero knowledge proofs</em> are proofs that fully convince that a statement is true without yielding <em>any additional knowledge</em>.
So, after seeing a zero knowledge proof that $m$ has a factor ending with $7$, you&rsquo;ll be no
closer to knowing $m$&rsquo;s factorization than you were before.
Zero knowledge proofs were invented by Goldwasser, Micali and Rackoff in 1982 and have since been used in great many settings.
How would you achieve such a thing, or even define it? And why on earth would it be useful?
This is the topic of this lecture.</p>
<p>::: { .pause }
This chapter will rely on the notion of <strong>NP completeness</strong>, as well as the view of NP as proof systems. For a review of this notion, please see <a class="link" href="https://introtcs.org/public/lec_13_Cook_Levin.html"  target="_blank" rel="noopener"
    >this chapter of my introduction to TCS text</a>.
:::</p>
<h2 id="applications-for-zero-knowledge-proofs">Applications for zero knowledge proofs.
</h2><p>Before we talk about how to achieve zero knowledge, let us discuss some of its potential applications:</p>
<h3 id="nuclear-disarmament">Nuclear disarmament
</h3><p>The United States and Russia have reached a dangerous and expensive equilibrium where each has about <a class="link" href="https://www.armscontrol.org/factsheets/Nuclearweaponswhohaswhat"  target="_blank" rel="noopener"
    >7000 nuclear warheads</a>, much more than is needed to decimate each others&rsquo; population (and the population of much of the rest of the world).<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>
Having so many weapons increases the chance of &ldquo;leakage&rdquo; of weapons, or of an accidental launch (which can result in an all out war) through fault in communications or rogue commanders.
This also threatens the delicate balance of the <a class="link" href="https://en.wikipedia.org/wiki/Treaty_on_the_Non-Proliferation_of_Nuclear_Weapons"  target="_blank" rel="noopener"
    >Non-Proliferation Treaty</a> which at its core is a bargain where non-weapons states agree not to pursue nuclear weapons and the five nuclear weapon states agree to make progress on nuclear disarmament.
These huge quantities of nuclear weapons are not only dangerous, as they increase the chance of a leak or of an individual failure or rogue commander causing a world catastrophe, but also extremely expensive to maintain.</p>
<p>For all of these reasons, in 2009, U.S. President Obama called to set as a long term goal a &ldquo;world without nuclear weapons&rdquo; and in 2012 spoke concretely about talking to Russia about reducing &ldquo;not only our¬†strategic nuclear warheads, but also tactical weapons and warheads in reserve&rdquo;.
On the other side, Russian President Putin has said already in 2000 that he sees &ldquo;no obstacles that could hamper future deep cuts of strategic offensive armaments&rdquo;.
(Though as of 2018, political winds on both sides have shifted away from disarmament and more toward armament.)</p>
<p>There are many reasons why progress on nuclear disarmament has been so slow, and most of them have nothing to do with zero knowledge or any other piece of technology.
But there are some technical hurdles as well.
One of those hurdles is that for the U.S. and Russia to go beyond restricting the number of <em>deployed</em> weapons to significantly reducing the <em>stockpiles</em>, they need to find a way for one country to verifiably prove that it has dismantled warheads.
As mentioned in my <a class="link" href="http://www.nature.com/nature/journal/v510/n7506/full/nature13457.html"  target="_blank" rel="noopener"
    >work with Glaser and Goldston</a> (see also <a class="link" href="http://nuclearfutures.princeton.edu/warhead-verification/"  target="_blank" rel="noopener"
    >this page</a>), a key stumbling block is that the design of a nuclear warhead is of course highly classified and about the last thing in the world that the U.S. would like to share with Russia and vice versa.
So, how can the U.S. convince the Russian that it has destroyed a warhead, when it cannot let Russian experts anywhere near it?</p>
<h3 id="voting">Voting
</h3><p>Electronic voting has been of great interest for many reasons.
One potential advantage is that it could allow completely transparent vote counting, where every citizen could verify that the votes were counted correctly.
For example, Chaum suggested an approach to do so by publishing an encryption of every vote and then having the central authority <em>prove</em> that the final outcome corresponds to the counts of all the plaintexts.
But of course to maintain voter privacy, we need to prove this without actually revealing those plaintexts. Can we do so?</p>
<h3 id="more-applications">More applications
</h3><p>I chose these two examples above precisely because they are hardly the first that come to mind when thinking about zero knowledge.
Zero knowledge has been used for many cryptographic applications.
One such application (originating from work of Fiat and Shamir) is the use for <em>identification protocols</em>.
Here Alice knows a solution $x$ to a puzzle $P$, and proves her identity to Bob by, for example, providing an encryption $c$ of $x$ and proving in zero knowledge that
$c$ is indeed an encryption of a solution for $P$.<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>
Bob can verify the proof, but because it is zero knowledge, learns nothing about the solution of the puzzle and will not be able to impersonate Alice.
An alternative approach to such identification protocols is through using <em>digital signatures</em>; this connection goes both ways and zero knowledge proofs have been used by Schnorr and others as a basis for signature schemes.</p>
<p>Another very generic application is for &ldquo;compiling protocols&rdquo;. As we&rsquo;ve seen time and again, it is often much easier to handle <em>passive</em> adversaries than <em>active</em> ones.
(For example, it&rsquo;s much easier to get CPA security against the eavesdropping Eve than CCA security against the person-in-the-middle Mallory.)
Thus it would be wonderful if we could &ldquo;compile&rdquo; a protocol that is secure with respect to passive attacks into one that is secure with respect to active ones.
As was first shown by Goldreich, Micali, and Wigderson, zero knowledge proofs yield a very general such compiler.
The idea is that all parties prove in zero knowledge that they follow the protocol&rsquo;s specifications.
Normally, such proofs might require the parties to reveal their secret inputs, hence violating security, but zero knowledge precisely guarantees that we can verify correct behaviour without access to these inputs.</p>
<h2 id="defining-and-constructing-zero-knowledge-proofs">Defining and constructing zero knowledge proofs
</h2><p>So, zero knowledge proofs are wonderful objects, but how do we get them?
In fact, we haven&rsquo;t answered the even more basic question of how do we <em>define</em> zero knowledge?
We have to start by the most basic task of defining what we mean by a <em>proof</em>.</p>
<p>A <em>proof system</em> can be thought of as an algorithm $V$ (for &ldquo;verifier&rdquo;) that takes as input a <em>statement</em> which is some string $x$ and another string $\pi$ known as the <em>proof</em> and outputs $1$ if and only if $\pi$ is a valid proof that the statement $x$ is correct.
For example:</p>
<ul>
<li>
<p>In <em>Euclidean geometry</em>, <em>statements</em> are geometric facts such as &ldquo;in any triangle the degrees sum to 180 degrees&rdquo; and the <em>proofs</em> are step by step derivations of the statements from the five basic <a class="link" href="https://en.wikipedia.org/wiki/Euclidean_geometry"  target="_blank" rel="noopener"
    >postulates</a>.</p>
</li>
<li>
<p>In <a class="link" href="https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory"  target="_blank" rel="noopener"
    ><em>Zermelo-Fraenkel + Axiom of Choice (ZFC)</em></a> a <em>statement</em> is some purported fact about sets (e.g., the Riemann Hypothesis<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>), and a <em>proof</em> is a step by step derivation of it from the axioms.</p>
</li>
<li>
<p>We can define many other &ldquo;theories&rdquo;. For example, a theory where the statements are pairs $(x,m)$ such that $x$ is a quadratic residue modulo $m$  and a proof for $x$ is the number $s$ such that $x=s^2 \pmod{m}$, or a theory where the theorems are <em>Hamiltonian</em> graphs $G$ (graphs on $n$ vertices that contain an $n$-long cycle) and the proofs are the description of the cycle.</p>
</li>
</ul>
<p>All these proof systems have the property that the verifying algorithm $V$ is <em>efficient</em>.
Indeed, that&rsquo;s the whole point of a proof $\pi$- it&rsquo;s a sequence of symbols that makes it easy to verify that the statement is true.</p>
<!-- We will also assume for the sake of simplicity that the proof $\pi$ is always of length at most polynomial in the statement $x$.
While this is not necessarily always the case, in our setting, we can always think of the length of the proof as an extra input, but it's convenient to think of it as simply being contained in the statement.   -->
<p>To achieve the notion of zero knowledge proofs, Goldwasser and Micali had to consider a generalization of proofs from static sequences of symbols to <em>interactive probabilistic protocols</em> between a prover and a verifier.
Let&rsquo;s start with an informal example.
The vast majority of humans have three types of cone cells in their eyes.
The reason why <a class="link" href="http://www.patarnott.com/atms749/pdf/blueSkyHumanResponse.pdf"  target="_blank" rel="noopener"
    >we perceive the sky as blue</a> (see also <a class="link" href="https://www.forbes.com/sites/briankoberlein/2017/01/11/earths-skies-are-violet-we-just-see-them-as-blue/#33aaaf0f735f"  target="_blank" rel="noopener"
    >this</a>), despite its color being quite a different spectrum than the blue of the rainbow, is that the projection of the sky&rsquo;s color to our cones is closest to the projection of blue.
It has been suggested that a tiny fraction of the human population might have four functioning cones (in fact, only women, as it would require two X chromosomes and a certain mutation).
How would a person <em>prove</em> to another that she is a in fact such a <a class="link" href="https://en.wikipedia.org/wiki/Tetrachromacy"  target="_blank" rel="noopener"
    >tetrachromat</a>?</p>
<blockquote>
<p><strong>Proof of tetrachromacy:</strong></p>
<p>Suppose that Alice is a tetrachromat and can distinguish between the colors of two pieces of plastic that would be identical to a trichromat. She wants to prove to a trichromat Bob that the two pieces are not identical. She can do this as follows:</p>
</blockquote>
<p>Alice and Bob will repeat the following experiment $n$ times: Alice turns her back and Bob tosses a coin and with probability 1/2 leaves the pieces as they are, and with probability 1/2 switches the right piece with the left piece. Alice needs to guess whether Bob switched the pieces or not.</p>
<blockquote>
</blockquote>
<p>If Alice is successful in all of the $n$ repetitions then Bob will have $1-2^{-n}$ confidence that the pieces are truly different.</p>
<p>A similar &ldquo;proof&rdquo; inspired the influential notion of <em>hypothesis testing</em> in statistics. Dr. <a class="link" href="https://www.sciencehistory.org/distillations/ronald-fisher-a-bad-cup-of-tea-and-the-birth-of-modern-statistics"  target="_blank" rel="noopener"
    >Muriel Bristol</a> said that she prefers the taste of tea when the milk is put first into the cup and tea later, rather than vice versa.
The statistician Ronald Fisher did not believe her. William Roach (like Bristol, a chemist, and her future husband)  proposed a probabilistic test, whereby eight cups would be poured for Bristol, each randomly chosen to either be &ldquo;milk first&rdquo; or &ldquo;tea first&rdquo;. Bristol correctly identified all 8 cups.
Pondering about this experiment, and the level of confidence that it enabled to reject the &ldquo;null hypothesis&rdquo; that Bristol simply guessed randomly led to Fisher&rsquo;s development of hypothesis testing and the now ubiquitous &ldquo;$p$ values&rdquo;.</p>
<p>We now consider a more &ldquo;mathematical&rdquo; example along similar lines.
Recall that if $x$ and $m$ are numbers then we say that $x$ is a <em>quadratic residue</em> modulo $m$ if there is some $s$ such that $x=s^2 \pmod{m}$.
Let us define the function $NQR(m,x)$ to output $1$ if and only if $x \neq s^2 \pmod{m}$ for every $s \in {0,\ldots, m-1}$.
There is a very simple way to prove statements of the form &ldquo;$NQR(m,x)=0$&rdquo;: just give out $s$.
However, here is an interactive proof system to prove statements of the form &ldquo;$NQR(m,x)=1$&rdquo;:</p>
<ul>
<li>
<p>We have two parties: <strong>Alice</strong> and <strong>Bob</strong>. The <strong>common input</strong> is $(m,x)$ and Alice wants to convince Bob that $NQR(m,x)=1$. (That is, that $x$ is <em>not</em> a quadratic residue modulo $m$).</p>
</li>
<li>
<p>We assume that Alice can compute $NQR(m,w)$ for every $w\in {0,\ldots,m-1}$  but Bob is polynomial time.</p>
</li>
<li>
<p>The protocol will work as follows:</p>
</li>
</ul>
<ol>
<li>
<p>Bob will pick some random $s\in \Z^*_m$ (e.g., by picking a random number in ${1,\ldots,m-1}$  and discard it if it has nontrivial g.c.d. with $m$) and toss a coin $b\in{0,1}$. If $b=0$ then Bob will send $s^2 \pmod{m}$ to Alice and otherwise he will send $xs^2 \pmod{m}$ to Alice.</p>
</li>
<li>
<p>Alice will use her ability to compute $NQR(m,\cdot)$ to respond with $b&rsquo;=0$ if Bob sent a quadratic residue and with $b&rsquo;=1$ otherwise.</p>
</li>
<li>
<p>Bob <em>accepts</em> the proof if $b=b&rsquo;$.</p>
</li>
</ol>
<p>To see that Bob will indeed accept the proof, note that if $x$ is a non-residue then $xs^2$ will have to be a non-residue as well (since if it had a root $s&rsquo;$ then $s&rsquo;s$ would be a root of $xs^2$). Hence it will always be the case that $b&rsquo;=b$.</p>
<p>Moreover, if $x$ <em>was</em> a quadratic residue of the form $x=s&rsquo;^2 \pmod{m}$ for some $s&rsquo;$, then $xs^2=(s&rsquo;s)^2$ is simply a random quadratic residue, which means that in this case Bob&rsquo;s message is distributed the same regardless of whether $b=0$ or $b=1$, and no matter what she does, Alice has probability at most $1/2$ of guessing $b$.
Hence if Alice is always successful than after $n$ repetitions Bob would have $1-2^{-n}$ confidence that $x$ is indeed a non-residue modulo $m$.</p>
<blockquote>
<h1 id="heading">
</h1></blockquote>
<p>Please stop and make sure you see the similarities between this protocol and the one for demonstrating that the two pieces of plastic do not have identical colors.</p>
<p>Let us now make the formal definition:</p>
<p>::: {.definition title=&ldquo;Proof systems&rdquo; #proofsystemdef}
Let $f:{0,1}^* \rightarrow {0,1}$ be some function.
A <em>probabilistic proof for $f$</em> (i.e., a proof for statements of the form &ldquo;$f(x)=1$&rdquo;) is a pair of interactive algorithms $(P,V)$ such that $V$ runs in polynomial time and they satisfy:</p>
<ul>
<li>
<p><strong>Completeness:</strong> If $f(x)=1$ then on input $x$, if $P$ and $V$ are given input $x$ and interact, then at the end of the interaction $V$ will output <code>Accept</code> with probability at least $0.9$.</p>
</li>
<li>
<p><strong>Soundness:</strong> If If $f(x)=0$ then for any arbitrary (efficient or non efficient) algorithm $P^<em>$, if $P^</em>$ and $V$ are given input $x$  and interact then at the end $V$ will output <code>Accept</code> with probability at most $0.1$.
:::</p>
</li>
</ul>
<blockquote>
<h1 id="funclangrem">
</h1></blockquote>
<p>In many texts proof systems are defined with respect to <em>languages</em> as opposed to <em>functions</em>. That is, instead of talking about a function $f:{0,1}^* \rightarrow {0,1}$ we talk about a <em>language</em> $L \subseteq {0,1}^*$.
These two viewpoints are completely equivalent via the mapping $f \longleftrightarrow L$ where $L = { x ;| f(x) = 1 }$.</p>
<p>Note that we don&rsquo;t necessarily require the prover to be efficient (and indeed, in some cases it might not be).
On the other hand, our soundness condition holds even if the prover uses a non efficient strategy.<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>
We say that a proof system has an <em>efficient prover</em> if there is an NP-type proof system $\Pi$ for $L$ (that is some efficient algorithm $\Pi$ such that there exists $\pi$ with $\Pi(x,\pi)=1$ iff $x\in L$ and such that $\Pi(x,\pi)=1$ implies that $|\pi|\leq poly(|x|)$, such that the strategy for $P$ can be implemented efficiently given any static proof $\pi$ for $x$ in this system.</p>
<blockquote>
<h1 id="strategies">
</h1></blockquote>
<p>Up until now, we always considered cryptographic protocols where Alice and Bob trusted one another, but were worried about some adversary controlling the channel between them. Now we are in a somewhat more &ldquo;suspicious&rdquo; setting where the parties do not fully trust one another. In such protocols there is always a &ldquo;prescribed&rdquo; or <strong>honest</strong> strategy that a particular party <em>should</em> follow, but we generally don&rsquo;t want the other parties&rsquo; security to rely on someone else&rsquo;s good intention, and hence analyze also the case where a party uses an arbitrary <strong>malicious</strong> strategy. We sometimes also consider the <strong>honest but curious</strong> case where the adversary is passive and only collects information, but does not deviate from the prescribed strategy.</p>
<blockquote>
</blockquote>
<p>Protocols typically only guarantee security for party A when it behaves honestly - a party can always chose to violate its own security and there is not much we can (or should?) do about it.</p>
<h2 id="defining-zero-knowledge">Defining zero knowledge
</h2><p>So far we merely defined the notion of an interactive proof system, but we need to define what it means for a proof to be <em>zero knowledge</em>.
Before we attempt a definition, let us consider an example.
Going back to the notion of quadratic residuosity, suppose that $x$ and $m$ are public and Alice knows $s$ such that $x=s^2 \pmod{m}$.
She wants to convince Bob that this is the case.
However she prefers not to reveal $s$.
Can she convince Bob that such an $s$ exists without revealing any information about it? Here is a way to do so:</p>
<p><strong>Protocol ZK-QR:</strong> Public input for Alice and Bob: $x,m$; Alice&rsquo;s private input is $s$ such that $x=s^2 \pmod{m}$.</p>
<ol>
<li>
<p>Alice will pick a random $s&rsquo;$ and send to Bob $x&rsquo; = xs&rsquo;^2 \pmod{m}$.</p>
</li>
<li>
<p>Bob will pick a random bit $b\in{0,1}$ and send $b$ to Alice.</p>
</li>
<li>
<p>If $b=0$ then Alice reveals $ss&rsquo;$, hence giving out a root for $x&rsquo;$; if $b=1$ then Alice reveals $s&rsquo;$, hence showing a root for $x&rsquo;x^{-1}$.</p>
</li>
<li>
<p>Bob checks that the value $s&rsquo;&rsquo;$ revealed by Alice is indeed a root of $x&rsquo;x^{-b}$, if so then it &ldquo;accepts&rdquo; the proof.</p>
</li>
</ol>
<p>If $x$ was <em>not</em> a quadratic residue then no matter how $x&rsquo;$ was chosen, either $x&rsquo;$ or $x&rsquo;x^{-1}$ is <em>not</em> a residue and hence Bob will reject the proof with probability at least $1/2$.
By repeating this $n$ times, we can reduce the probability of Bob accepting the proof of a non residue to $2^{-n}$.</p>
<p>On the other hand, we claim that we didn&rsquo;t really reveal anything about $s$.
Indeed, if Bob chooses $b=0$, then the two messages $(x&rsquo;,ss&rsquo;)$ he sees can be thought of as a random quadratic residue $x&rsquo;$ and its root.
If Bob chooses $b=1$ then after dividing by $x$ (which he could have done by himself) he still gets a random residue $x&rsquo;&rsquo;$ and its root $s&rsquo;$.
In both cases, the distribution of these two messages is completely independent of $s$, and hence intuitively yields no additional information about it beyond whatever Bob knew before.</p>
<p>To define zero knowledge mathematically we follow the following intuition:</p>
<blockquote>
<p><em>A proof system is zero knowledge if the verifier did not learn anything after the interaction that he could not have learned on his own.</em></p>
</blockquote>
<p>Despite the name &ldquo;zero knowledge&rdquo;, we do not claim that the verifier does not know anything about the private input $x$. For example, if 1$m=p\cdot q$ for two primes $p,q$, then each $s \in \Z^*_m$ has at most four square roots, and if the verifier could compute square roots then they can narrow $x$ down to these four possibilities. However, the point is that this is knowledge that the verifier already even before the interaction with the prover, and so participating in the proof resulted in <em>zero additional knowledge</em>.</p>
<p>Here is how we formally define zero knowledge:</p>
<p>::: {.definition title=&ldquo;Zero knowledge proofs&rdquo; #zkpdef}
A proof system $(P,V)$ for $f$ is <em>zero knowledge</em> if for every efficient verifier strategy $V^<em>$
there exists an efficient probabilistic algorithm $S^</em>$ (known as the <em>simulator</em>) such that for every $x$ s.t. $f(x)=1$,
the following random variables are computationally indistinguishable:</p>
<ul>
<li>
<p>The output of $V^*$ after interacting with $P$ on input $x$.</p>
</li>
<li>
<p>The output of $S^*$ on input $x$.
:::</p>
</li>
</ul>
<p>That is, we can show the verifier does not gain anything from the interaction, because no matter what algorithm $V^<em>$ he uses, whatever he learned as a result of interacting with the prover, he could have just as equally learned by simply running the standalone algorithm $S^</em>$ on the same input.</p>
<p>::: {.remark title=&ldquo;The simulation paradigm&rdquo; #simulationrem}
The natural way to define security is to say that a system is secure if some &ldquo;laundry list&rdquo; of bad outcomes X,Y,Z can&rsquo;t happen.
The definition of zero knowledge is different. Rather than giving a list of the events that are <em>not allowed</em> to occur, it gives a maximalist <em>simulation</em> condition.</p>
<p>At its heart the definition of zero knowledge says the following: clearly, we cannot prevent the verifier from running an efficient algorithm $S^*$ on the public input, but we want to ensure that this is the most he can learn from the interaction.</p>
<p>This <em>simulation paradigm</em> has become the standard way to define security of a great many cryptographic applications.
That is, we bound what an adversary Eve can learn by postulating some hypothetical adversary Lilith that is under much harsher conditions (e.g., does not get to interact with the prover) and ensuring that Eve cannot learn anything that Lilith couldn&rsquo;t have learned either.
This has an advantage of being the most conservative definition possible, and also phrasing security in <em>positive</em> terms- there exists a simulation - as opposed to the typical <em>negative</em> terms - events X,Y,Z can&rsquo;t happen. Since it&rsquo;s often easier for us to think of positive terms, paradoxically sometimes this stronger security condition is easier to prove. Zero knowledge is in some sense the simplest setting of the simulation paradigm and we&rsquo;ll see it time and again in dealing with more advanced notions.
:::</p>
<p>The definition of zero knowledge is confusing since intuitively if the verifier gained confidence that the statement is true than surely he must have learned <em>something</em>.
This is another one of those cases where cryptography is counterintuitive.
To understand it better, it is worthwhile to see the formal proof that the protocol above for quadratic residuosity is zero knowledge:</p>
<blockquote>
<h1 id="zkqrthm">
</h1></blockquote>
<p>Protocol ZK-QR above is a zero knowledge protocol.</p>
<p>::: {.proof data-ref=&ldquo;zkqrthm&rdquo;}
Let $V^*$ be an arbitrary efficient strategy for Bob.
Since Bob only sends a single bit, we can think of this strategy as composed of two functions:</p>
<ul>
<li>
<p>$V_1(x,m,x&rsquo;)$ outputs the bit $b$ that Bob chooses on input $x,m$ and after Alice&rsquo;s first message is $x&rsquo;$.</p>
</li>
<li>
<p>$V_2(x,m,x&rsquo;,s&rsquo;&rsquo;)$ is whatever Bob outputs after seeing Alice&rsquo;s response $s&rsquo;&rsquo;$ to the bit $b$.</p>
</li>
</ul>
<p>Both $V_1$ and $V_2$ are efficiently computable. We now need to come up with an efficient simulator $S^<em>$ that is a standalone algorithm that on input $x,m$ will output a distribution indistinguishable from the output $V^</em>$.</p>
<p>The simulator $S^*$ will work as follows:</p>
<ol>
<li>
<p>Pick $b&rsquo;\leftarrow_R{0,1}$.</p>
</li>
<li>
<p>Pick $s&rsquo;&rsquo;$ at random in $\Z^*_m$. If $b=0$ then let $x&rsquo;={s&rsquo;&rsquo;}^2 \pmod{m}$. Otherwise output $x&rsquo;=x{s&rsquo;&rsquo;}^2 \pmod{m}$.</p>
</li>
<li>
<p>Let $b=V_1(x,m,x&rsquo;)$. If $b \neq b&rsquo;$ then go back to step 1.</p>
</li>
<li>
<p>Output $V_2(x,m,x&rsquo;,s&rsquo;&rsquo;)$.</p>
</li>
</ol>
<p>The correctness of the simulator follows from the following claims (all of which assume that $x$ is actually a quadratic residue, since otherwise
we don&rsquo;t need to make any guarantees and in any case Alice&rsquo;s behaviour is not well defined):</p>
<p><strong>Claim 1:</strong> The distribution of $x&rsquo;$ computed by $S^*$ is identical to the distribution of $x&rsquo;$ chosen by Alice.</p>
<p><strong>Claim 2:</strong> With probability at least $1/2$, $b&rsquo;=b$.</p>
<p><strong>Claim 3:</strong> Conditioned on $b=b&rsquo;$ and the value $x&rsquo;$ computed in step 2, the value $s&rsquo;&rsquo;$ computed by $S^*$ is identical to the value that Alice sends when her first message is $x&rsquo;$ and Bob&rsquo;s response is $b$.</p>
<p>Together these three claims imply that in expectation $S^<em>$ only invokes $V_1$ and $V_2$ a constant number of times (since every time it goes back to step 1 with probability at most $1/2$).
They also imply that the output of $S^</em>$ is in fact identical to the output of $V^*$ in a true interaction with Alice.
Thus, we only need to prove the claims, which is actually quite easy:</p>
<p><strong>Proof of Claim 1:</strong> In both cases, $x&rsquo;$ is a random quadratic residue. <strong>QED (Claim 1)</strong></p>
<p><strong>Proof of Claim 2:</strong> This is a corollary of Claim 1; since the distribution of $x&rsquo;$ is identical to the distribution chosen by Alice, in particular $x&rsquo;$ gives out no information about the choice of $b&rsquo;$. <strong>QED (Claim 2)</strong></p>
<p><strong>Proof of Claim 3:</strong> This follows from a direct calculation. The value $s&rsquo;&rsquo;$ sent by Alice is a square root of $x&rsquo;$ if $b=0$ and of $x&rsquo;x^{-1}$ if $x=1$. But this is identical to what happens for $S^*$ if $b=b&rsquo;$. <strong>QED (Claim 3)</strong></p>
<p>Together these complete the proof of the theorem.
:::</p>
<p><a class="link" href="" >zkqrthm</a>{.ref} is interesting but not yet good enough to guarantee security in practice.
After all, the protocol that we really need to show is zero knowledge is the one where we repeat this procedure $n$ times.
This is a general theorem that if a protocol is zero knowledge then repeating it polynomially many times one after the other
(so called &ldquo;sequential repetition&rdquo;) preserves zero knowledge.
You can think of this as cryptography&rsquo;s version of the equality &ldquo;$0+0=0$&rdquo;, but as usual, intuitive things are not always correct and so this theorem does require (a not super trivial) proof.
It is a good exercise to try to prove it on your own.
There are known ways to achieve zero knowledge with negligible soundness error and a <em>constant</em> number of communication rounds, see Goldreich&rsquo;s book (Vol 1, Sec 4.9).</p>
<h2 id="zero-knowledge-proof-for-hamiltonicity">Zero knowledge proof for Hamiltonicity.
</h2><p>We now show a proof for another language.</p>
<p>Suppose that Alice and Bob know an $n$-vertex graph $G$ and Alice knows a <em>Hamiltonian cycle</em> $C$ in this graph  (i.e. a length $n$ simple cycle - one that traverses all vertices exactly once).
Here is how Alice can prove that such a cycle exists without revealing any information about it.</p>
<p><strong>Protocol ZK-Ham:</strong></p>
<ol start="0">
<li>
<p><strong>Common input:</strong> graph $H$ (in the form of an $n\times n$ adjacency matrix). <strong>Alice&rsquo;s private input:</strong> a Hamiltonian cycle $C=(C_1,\ldots,C_n)$ which are distinct vertices such that $(C_\ell,C_{\ell+1})$ is an edge in $H$ for all $\ell\in{1,\ldots,n-1}$ and $(C_n,C_1)$ is an edge as well. Below we assume that $G:{0,1}^n \rightarrow{0,1}^{3n}$ is a pseudorandom generator.</p>
</li>
<li>
<p>Bob chooses a random string $z\in {0,1}^{3n}$</p>
</li>
<li>
<p>Alice chooses a random permutation $\pi$ on ${1,\ldots, n}$ and let $M$ be the $\pi$-permuted adjacency matrix of $H$  (i.e., $M_{\pi(i),\pi(j)}=1$ iff $(i,j)$ is an edge in $H$). For every $i,j$, Alice chooses a random string $x_{i,j} \in {0,1}^n$ and let $y_{i,j}=G(x_{i,j})\oplus M_{i,j}z$. She sends ${ y_{i,j} }_{i,j \in [n]}$ to Bob.</p>
</li>
<li>
<p>Bob chooses a bit $b\in{0,1}$.</p>
</li>
<li>
<p>If $b=0$ then Alice sends out $\pi$ and the strings ${ x_{i,j} }$ for all $i,j$; if $b=1$ then Alice sends out the $n$ strings $x_{\pi(C_1),\pi(C_2)},\ldots,x_{\pi(C_n),\pi(C_1)}$ together with their indices.</p>
</li>
<li>
<p>If $b=0$ then Bob computes $M$ to be the $\pi$-permuted adjacency matrix of $H$ and verifies that all the $y_{i,j}$&rsquo;s were computed from the $x_{i,j}$&rsquo;s appropriately. If so then Bob accepts the proof, and otherwise it rejects it. If $b=1$ then Bob verifies that the indices of the strings ${ x_{i,j } }$ sent by Alice form a cycle and that indeed $y_{i,j}=G(x_{i,j})\oplus z$ for every string $x_{i,j}$ that was sent by Alice. If so then Bob accepts the proof and otherwise he rejects it.</p>
</li>
</ol>
<blockquote>
<h1 id="zkhamthm">
</h1></blockquote>
<p>Protocol ZK-Ham is a zero knowledge proof system for the language of Hamiltonian graphs.<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup></p>
<p>::: {.proof data-ref=&ldquo;zkhamthm&rdquo;}
We need to prove <strong>completeness</strong>, <strong>soundness</strong>, and <strong>zero knowledge</strong>.</p>
<p><strong>Completeness</strong> can be easily verified, and so we leave this to the reader.</p>
<p>For <strong>soundness</strong>, we recall that (as we&rsquo;ve seen before) with extremely high probability the sets $S_0={ G(x) : x\in{0,1}^n }$ and $S_1 = { G(x)\oplus z : x\in{0,1}^n }$ will be disjoint (this probability is over the choice of $z$ that is done by the verifier).
Now, assuming this is the case, given the messages ${ y_{i,j} }$ sent by the prover in the first step, define an $n\times n$ matrix $M&rsquo;$ with entries in ${0,1,?}$ as follows: $M&rsquo;<em>{i,j}=0$ if $y</em>{i,j}\in S_0$ , $M&rsquo;<em>{i,j}=1$ if $y</em>{i,j}\in S_1$ and $M&rsquo;_{i,j}=?$ otherwise.</p>
<p>We split into two cases.
The first case is that there exists some permutation $\pi$ such that <strong>(i)</strong> $M&rsquo;$ is a $\pi$-permuted version of the input graph $H$ and <strong>(ii)</strong> $M&rsquo;$ contains a Hamiltonian cycle. Clearly in this case $H$ contains a Hamiltonian cycle as well, and hence we don&rsquo;t need to consider it when analyzing soundness. In the other case we claim that with probability at least $1/2$ the verifier will reject the proof.
Indeed, if <strong>(i)</strong> is violated then the proof will be rejected if Bob chooses $b=0$ and if <strong>(ii)</strong> is violated then the proof will be rejected if Bob chooses $b=1$.</p>
<p>We now turn to showing <strong>zero knowledge</strong>. For this we need to build a <em>simulator</em> $S^<em>$ for an arbitrary efficient strategy $V^</em>$ of Bob.
Recall that $S^<em>$ gets as input the graph $H$ (but not the <em>Hamiltonian</em> cycle $C$) and needs to produce an output that is indistinguishable from the output of $V^</em>$.
It will do so as follows:</p>
<ol start="0">
<li>
<p>Pick $b&rsquo;\in{0,1}$.</p>
</li>
<li>
<p>Let $z\in {0,1}^{3n}$ be the first message computed by $V^*$ on input $H$.</p>
</li>
<li>
<p>If $b&rsquo;=0$ then $S^<em>$ computes the second message as Alice does: chooses a random permutation $\pi$ on ${1,\ldots, n}$ and let $M$ be the $\pi$-permuted adjacency matrix of $H$  (i.e., $M_{\pi(i),\pi(j)}=1$ iff $(i,j)$ is an edge in $H$). In contrast, if $b&rsquo;=1$ then $S^</em>$ lets $M$ be the all $1$s matrix. For every $i,j$, $S^*$ chooses a random string $x_{i,j} \in {0,1}^n$ and let $y_{i,j}=G(x_{i,j})\oplus M_{i,j}z$, where $G:{0,1}^n\rightarrow{0,1}^{3n}$ is a pseudorandom generator.</p>
</li>
<li>
<p>Let $b$ be the output of $V^*$ when given the input $H$ and the first message ${ y_{i,j} }$ computed as above. If $b\neq b&rsquo;$ then go back to step 0.</p>
</li>
<li>
<p>We compute the fourth message of the protocol similarly to how Alice does it: if $b=0$ then it consists of $\pi$ and the strings ${ x_{i,j} }$ for all $i,j$; if $b=1$ then we pick a random length-$n$ cycle $C&rsquo;$  and the message consists of the $n$ strings $x_{C&rsquo;_1,C&rsquo;<em>2},\ldots,x</em>{C&rsquo;_n,C&rsquo;_1}$ together with their indices.</p>
</li>
<li>
<p>Output whatever $V^*$ outputs when given the prior message.</p>
</li>
</ol>
<p>We prove the output of the simulator is indistinguishable from the output of $V^*$ in an actual interaction by the following claims:</p>
<p><strong>Claim 1:</strong> The message ${ y_{i,j} }$ computed by $S^*$ is computationally indistinguishable from the first message computed by Alice.</p>
<p><strong>Claim 2:</strong> The probability that $b=b&rsquo;$ is at least $1/3$.</p>
<p><strong>Claim 3:</strong> The fourth message computed by $S^*$ is computationally indistinguishable from the fourth message computed by Alice.</p>
<p>We will simply sketch here the proofs (see Goldreich&rsquo;s book for example for full proofs):</p>
<p>For Claim 1, note that if $b&rsquo;=0$ then the message is <em>identical</em> to the way Alice computes it.
If $b&rsquo;=1$ then the difference is that $S^*$ computes some strings $y_{i,j}$ of the form $G(x_{i,j})+z$ where Alice would compute the corresponding strings as $G(x_{i,j})$ this is indistinguishable because $G$ is a pseudorandom generator (and the distribution $U_{3n}\oplus z$ is the same as $U_{3n}$).</p>
<p>Claim 2 is a corollary of Claim 1. If $V^<em>$ managed to pick a message $b$ such that $\Pr[ b=b&rsquo; ] &lt; 1/2 - negl(n)$ then in particular it could distinguish between the first message of Alice (that is computed independently of $b&rsquo;$ and hence contains no information about it) from the first message of $V^</em>$.</p>
<p>For Claim 3, note that again if $b=0$ then the message is computed in a way identical to what Alice does. If $b=1$ then this message is also computed in a way identical to Alice, since it does not matter if instead of picking $C&rsquo;$ at random, we picked a random permutation $\pi$ and let $C&rsquo;$ be the image of the Hamiltonian cycle under this permutation.</p>
<p>This completes the proof of the theorem.
:::</p>
<h3 id="why-is-this-interesting">Why is this interesting?
</h3><p>The reason that a protocol for Hamiltonicity is more interesting than a protocol for quadratic residuosity is that Hamiltonicity is an <em>NP-complete</em> problem.
Specifically recall the following:</p>
<ul>
<li>
<p>A function $F:{0,1}^* \rightarrow {0,1}$ is in NP if there exists a polynomial-time algorithm $V_F$ and some integer $c$ such that for every $x\in {0,1}^*$, $F(x)=1$ iff there exists $y \in {0,1}^{|x|^c}$ such that $V_F(x,y)=1$. Many functions of interest in all areas of math, science, engineering, and more  are in the class NP.</p>
</li>
<li>
<p>Let $HAM:{0,1}^* \rightarrow {0,1}$ be the function that maps a graph $G$ to $1$ if and only if $G$ contains a Hamiltonian cycle. Then $HAM \in NP$. Indeed, this is demonstrated by the function $V_{HAM}$ such that $V_{HAM}(G,C)=1$ iff $C$ is a Hamiltonian cycle in the graph $G$.</p>
</li>
<li>
<p>The function $HAM$ is NP-complete. Specifically for every $F,V_F$ as above, there is are efficiently computable functions $r, r_{Encode}, r_{Decode}$ that satisfy the following:
a. (Completeness of reduction.) For every $x,y$ such that $V_F(x,y)=1$, $V_{HAM}( r(x), r_{Encode}(x,y))=1$.  In particular this means that for every $x$ such that $F(x)=1$, $HAM(r(x))=1$. (Can you see why?)
b. (Soundness of reduction.) For every $x \in {0,1}^*$, if there exists $C$ such that $V_{HAM}(r(x),C)=1$ then $V_F(x,r_{Decode}(x,C))=1$. In particular this means that for every $x$ such that $HAM(r(x))=1$, $F(x)=1$. (Can you see why?)</p>
</li>
</ul>
<p>Using the reduction above, we can transform the zero-knowledge proof for Hamiltonicity into a zero knowledge proof for every $F\in NP$.
Specifically, to prove that $F(x)=1$, the verifier and prover will use the following system (see also <a class="link" href="" >zkhamnpcfig</a>{.ref}).</p>
<ol>
<li>
<p><strong>Public input:</strong> $x$. <strong>Prover&rsquo;s private input:</strong> $y$ such that $V_F(x,y)=1$.</p>
</li>
<li>
<p>Verifier and prover will compute $G=r(x)$. Prover will compute $C=r_{Encode}(x,y)$.</p>
</li>
<li>
<p>Verifier and prove run the Hamiltonicity zero knowledge protocol, with public input $G$ and prover&rsquo;s private input $C$. The verifier&rsquo;s output is the output in this protocol.</p>
</li>
</ol>
<p><img src="/figure/zk-ham.jpg"
	
	
	
	loading="lazy"
	
		alt="Using a zero knowledge protocol for Hamiltonicity we can obtain a zero knowledge protocol for any language $L$ in NP. For example, if the public input is a SAT formula $\varphi$ and the Prover&rsquo;s secret input is a satisfying assignment $x$ for $\varphi$ then the verifier can run the reduction on $\varphi$ to obtain a graph $H$ and the prover can run the same reduction to obtain from $x$ a Hamiltonian cycle $C$ in $H$. They can then run the ZK-Ham protocol to prove that indeed $H$ is Hamiltonian (and hence the original formula was satisfiable) without revealing any information the verifier could not have obtain on his own."
	
	
>{#zkhamnpcfig width=80% }</p>
<p>::: { .pause }
Please make sure that you understand why this will give a zero knowledge proof for $F$, and in particular satisfy the completeness, soundness, and zero-knowledge properties.</p>
<p>Note that while the NP completeness of Hamiltonicity (and the Cook-Levin Theorem in general) is usually perceived as a <em>negative result</em> (showing evidence for the non-existence of an algorithm), in this context we use it to obtain a <em>positive result</em> (zero knowledge proof systems for many interesting functions).
:::</p>
<p>This means that for every other NP language $L$, we can use the reduction from $L$ to Hamiltonicity combined with protocol ZK-Ham to give a zero knowledge proof system for $L$. In particular this means that we can have zero knowledge proofs for the following languages:</p>
<ul>
<li>
<p>The language of numbers $m$ such that there exists a prime $p$ dividing $m$ whose remainder modulo $10$ is $7$.</p>
</li>
<li>
<p>The language of tuples $X,e,c_1,\ldots,c_n$ such that $c_i$ is an encryption of a number $x_i$ with $\sum x_i = X$. (This is essentially what we needed in the voting example above).</p>
</li>
<li>
<p>For every efficient function $G$, the language of pairs $x,y$ such that there exists some input $r$ satisfying $y=G(x|r)$. (This is what we often need in the &ldquo;protocol compiling&rdquo; applications to show that a particular output was produced by the correct program $G$ on public input $x$ and private input $r$.)</p>
</li>
</ul>
<h2 id="parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures">Parallel repetition and turning zero knowledge proofs to signatures.
</h2><p>While we talked about amplifying zero knowledge proofs by running them $n$ times one <em>after</em> the other, one could also imagine running the $n$ copies <em>in parallel</em>.
It is not trivial that we get the same benefit of reducing the error to $2^{-n}$ but it turns out that we do in the cases we are interested in here.
Unfortunately, zero knowledge is not necessarily preserved.
It&rsquo;s an important open problem whether zero knowledge is preserved for the ZK-Ham protocol mentioned above.<br>
However, Fiat and Shamir showed that in protocols (such as the ones we showed here) where the verifier only sends random bits, then if we replaced this verifier by a <em>random function</em>, then both soundness and zero knowledge are preserved.
This suggests a <em>non-interactive</em> version of these protocols in the random oracle model, and this is indeed widely used.
Schnorr designed signatures based on this non interactive version.</p>
<h3 id="bonus-features-of-zero-knowledge">&ldquo;Bonus features&rdquo; of zero knowledge
</h3><p>The following properties of zero knowledge systems are used in the literature. We might cover some in class, but mention them here. These are covered in Chapter 20 of Boneh-Shoup.</p>
<ul>
<li>
<p><em>Proof of knowledge</em> - it can be shown that the proof above of Hamiltonicity yields more than soundness. We can &ldquo;extract&rdquo; from a prover startegy that succeeds in convincing the verifier that $G$ is Hamiltonian with probability larger than 1/2 an actual Hamiltonian cycle. This means that the prover didn&rsquo;t just convince the verifier that there <em>exists</em> a Hamiltonian cycle in the graph $G$  but also that the prover &ldquo;knows&rdquo; it. This notion is known as a &ldquo;proof of knowledge&rdquo;.</p>
</li>
<li>
<p><em>Arguments</em> - if a proof system only satisfies the soundness condition with respect to polynomial-time provers, then it is called an <em>argument system</em>.</p>
</li>
<li>
<p><em>Succinct</em> proofs - proofs that $F(x)=1$ where total communication is a fixed polynomial in $n$ <em>independently</em> of the time to verify $F$.</p>
</li>
</ul>
<p>Combining succinct zero-knowledge proofs with the Fiat-Shamir heuristic for non-interactivity leads to the notion of <em>zero-knowledge succinct arguments</em> or ZK-SNARG.
If these also satisfy a &ldquo;proof of knowledge&rdquo; property then they are called <a class="link" href="https://eprint.iacr.org/2014/580"  target="_blank" rel="noopener"
    >ZK-SNARKs</a>. These have recently been of great interest for crypto-currencies.
See <a class="link" href="https://cs251.stanford.edu/syllabus.html"  target="_blank" rel="noopener"
    >lectures 16-18 in Stanford CS 251</a>, as well as this <a class="link" href="https://z.cash/technology/zksnarks/"  target="_blank" rel="noopener"
    >blog post</a>.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>To be fair, &ldquo;only&rdquo; about 170 million Americans live in the <a class="link" href="https://www.currentresults.com/Weather-Extremes/US/largest-cities-list.php"  target="_blank" rel="noopener"
    >50 largest metropolitan areas</a> and so arguably many people will survive at least the initial impact of a nuclear war, though it had been estimated that even a &ldquo;small&rdquo; nuclear war involving detonation of 100 not too large warheads could have <a class="link" href="http://onlinelibrary.wiley.com/doi/10.1002/2013EF000205/full"  target="_blank" rel="noopener"
    >devastating global consequences</a>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>As we&rsquo;ll see, technically what Alice needs to do in such a scenario is use a <em>zero knowledge proof of knowledge</em> of a solution for $P$.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Integers can be coded as sets in various ways. For example, one can encode $0$ as $\emptyset$ and if $N$ is the set encoding $n$, we can encode $n+1$ using the  $n+1$-element set ${ N } \cup N$.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>People have considered the notion of zero knowledge systems where soundness holds only with respect to efficient provers; these are known as <em>argument systems</em>.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>Goldreich, Micali and Wigderson were the first to come up with a zero knowledge proof for an NP complete problem, though the Hamiltoncity protocol here is from a later work by Blum. We use Naor&rsquo;s commitment scheme.&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 Example Person
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.26.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
