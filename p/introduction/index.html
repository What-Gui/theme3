<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="Introduction Additional reading: Chapters 1 and 2 of Katz-Lindell book. Sections 2.1 (Introduction) and 2.2 (Shannon ciphers and perfect security) in the Boneh Shoup book. 1\nEver since people started to communicate, there were some messages that they wanted kept secret. Thus cryptography has an old though arguably undistinguished history. For a long time cryptography shared similar features with Alchemy as a domain in which many otherwise smart people would be drawn into making fatal mistakes. Indeed, the history of cryptography is littered with the figurative corpses of cryptosystems believed secure and then broken, and sometimes with the actual corpses of those who have mistakenly placed their faith in these cryptosystems. The definitive text on the history of cryptography is David Kahn&rsquo;s &ldquo;The Codebreakers&rdquo;, whose title already hints at the ultimate fate of most cryptosystems.2 (See also &ldquo;The Code Book&rdquo; by Simon Singh.)\n">
<title>Introduction</title>

<link rel='canonical' href='http://localhost:1313/p/introduction/'>

<link rel="stylesheet" href="/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css"><meta property='og:title' content="Introduction">
<meta property='og:description' content="Introduction Additional reading: Chapters 1 and 2 of Katz-Lindell book. Sections 2.1 (Introduction) and 2.2 (Shannon ciphers and perfect security) in the Boneh Shoup book. 1\nEver since people started to communicate, there were some messages that they wanted kept secret. Thus cryptography has an old though arguably undistinguished history. For a long time cryptography shared similar features with Alchemy as a domain in which many otherwise smart people would be drawn into making fatal mistakes. Indeed, the history of cryptography is littered with the figurative corpses of cryptosystems believed secure and then broken, and sometimes with the actual corpses of those who have mistakenly placed their faith in these cryptosystems. The definitive text on the history of cryptography is David Kahn&rsquo;s &ldquo;The Codebreakers&rdquo;, whose title already hints at the ultimate fate of most cryptosystems.2 (See also &ldquo;The Code Book&rdquo; by Simon Singh.)\n">
<meta property='og:url' content='http://localhost:1313/p/introduction/'>
<meta property='og:site_name' content='Example Site'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' />
<meta name="twitter:title" content="Introduction">
<meta name="twitter:description" content="Introduction Additional reading: Chapters 1 and 2 of Katz-Lindell book. Sections 2.1 (Introduction) and 2.2 (Shannon ciphers and perfect security) in the Boneh Shoup book. 1\nEver since people started to communicate, there were some messages that they wanted kept secret. Thus cryptography has an old though arguably undistinguished history. For a long time cryptography shared similar features with Alchemy as a domain in which many otherwise smart people would be drawn into making fatal mistakes. Indeed, the history of cryptography is littered with the figurative corpses of cryptosystems believed secure and then broken, and sometimes with the actual corpses of those who have mistakenly placed their faith in these cryptosystems. The definitive text on the history of cryptography is David Kahn&rsquo;s &ldquo;The Codebreakers&rdquo;, whose title already hints at the ultimate fate of most cryptosystems.2 (See also &ldquo;The Code Book&rdquo; by Simon Singh.)\n">
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true}, 
                {left: "$", right: "$", display: false}  
            ]
        });
    });
</script>
<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
    };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu13739649187745961479.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">üç•</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Example Site</a></h1>
            <h2 class="site-description">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="http://localhost:1313/" selected>English</option>
                                
                                    <option value="http://localhost:1313/zh-cn/" >‰∏≠Êñá</option>
                                
                                    <option value="http://localhost:1313/ar/" >ÿπÿ±ÿ®Ÿä</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#some-history">Some history</a></li>
    <li><a href="#defining-encryptions">Defining encryptions</a></li>
    <li><a href="#defining-security-of-encryption">Defining security of encryption</a>
      <ol>
        <li><a href="#generating-randomness-in-actual-cryptographic-systems">Generating randomness in actual cryptographic systems</a></li>
      </ol>
    </li>
    <li><a href="#defining-the-secrecy-requirement">Defining the secrecy requirement.</a></li>
  </ol>

  <ol>
    <li><a href="#perfect-secrecy">Perfect Secrecy</a></li>
  </ol>

  <ol>
    <li>
      <ol>
        <li><a href="#achieving-perfect-secrecy">Achieving perfect secrecy</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#necessity-of-long-keys">Necessity of long keys</a>
      <ol>
        <li><a href="#longkeysthm"></a></li>
        <li><a href="#heading-4"></a></li>
        <li><a href="#amplifying-success-probability">Amplifying success probability</a></li>
      </ol>
    </li>
    <li><a href="#bibliographical-notes">Bibliographical notes</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/introduction/">Introduction</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    39 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="introduction">Introduction
</h1><p><strong>Additional reading:</strong> Chapters 1 and 2 of Katz-Lindell book. Sections 2.1 (Introduction) and 2.2 (Shannon ciphers and perfect security) in the Boneh Shoup book. <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>Ever since people started to communicate, there were some messages that they
wanted kept secret. Thus cryptography has an old though arguably <em>undistinguished</em> history. For a long time cryptography shared similar features with Alchemy as a domain in which many otherwise smart people would be drawn into making fatal mistakes. Indeed, the history of cryptography is littered with the figurative corpses of cryptosystems believed secure and then broken, and sometimes with the actual corpses of those who have mistakenly placed their faith in these cryptosystems.
The definitive text on the history of cryptography is David Kahn&rsquo;s &ldquo;The Codebreakers&rdquo;, whose title already hints at the ultimate fate of most cryptosystems.<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> (See also &ldquo;The Code Book&rdquo; by Simon Singh.)</p>
<p>We recount below just a few stories to get a feel for this field.
But before we do so, we should introduce the <strong>cast of characters</strong>.
The basic setting of &ldquo;encryption&rdquo; or &ldquo;secret writing&rdquo; is the following:
one person, whom we will call <strong>Alice</strong>, wishes to send another person, whom we will call <strong>Bob</strong>, a
<strong>secret</strong> message. Since Alice and Bob are not in the same room (perhaps because Alice is imprisoned in a castle by her cousin the queen of England), they cannot communicate directly and need to send their message in writing. Alas, there is a third person, whom we will call <strong>Eve</strong>, that can see their message.
Therefore Alice needs to find a way to <em>encode</em> or <em>encrypt</em> the message so that only Bob (and not Eve) will be able to understand it.</p>
<h2 id="some-history">Some history
</h2><p>In 1587, Mary the queen of Scots, and heir to the throne of England, wanted to arrange the assassination of her cousin, queen Elisabeth I of
England, so that she could ascend to the throne and finally escape the house arrest under which she had been for the last 18 years.
As part of this complicated plot, she sent a coded letter to Sir Anthony Babington.</p>
<p><img src="/figure/encrypted_letter.jpg"
	
	
	
	loading="lazy"
	
		alt="Snippet from encrypted communication between queen Mary and Sir Babington"
	
	
>{#maryscottletterfig .margin  }</p>
<p>Mary used what&rsquo;s known as a <em>substitution cipher</em> where each letter is transformed into a different obscure symbol (see <a class="link" href="" >maryscottletterfig</a>{.ref}).
At a first look, such a letter might seem rather inscrutable- a meaningless sequence of strange symbols.
However, after some thought, one might recognize that these symbols <em>repeat</em> several
times and moreover that different symbols repeat with different frequencies.
Now it doesn&rsquo;t take a large leap of faith to assume that perhaps each symbol corresponds to a different letter
and the more frequent symbols correspond to letters that occur in the alphabet with higher frequency.
From this observation, there is a short gap to completely breaking the cipher,
which was in fact done by queen Elisabeth&rsquo;s spies who used the decoded letters to learn of all the co-conspirators and to convict queen Mary of treason, a crime for which she was executed.
Trusting in superficial security measures (such as using &ldquo;inscrutable&rdquo; symbols) is a trap that users of cryptography have been falling into again and again over the years.
(As in many things, this is the subject of a great XKCD cartoon, see <a class="link" href="" >XKCDnavajofig</a>{.ref}.)</p>
<p><img src="/figure/code_talkers.png"
	
	
	
	loading="lazy"
	
		alt="XKCD&rsquo;s take on the added security of using uncommon symbols"
	
	
>{#XKCDnavajofig .margin  }</p>
<p>The <a class="link" href="https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher"  target="_blank" rel="noopener"
    >Vigen√®re cipher</a> is named after Blaise de Vigen√®re who described it in a book in 1586 (though it was invented earlier by Bellaso).
The idea is to use a collection of substitution ciphers - if there are $n$ different ciphers then the first letter of the plaintext is encoded with the first cipher, the second with the second cipher,
the $n^{th}$ with the $n^{th}$ cipher, and then the $n+1^{st}$ letter is again encoded with the first cipher.
The key is usually a word or a phrase of $n$ letters, and the $i^{th}$ substitution cipher is obtained by shifting each letter $k_i$ positions in the alphabet.
This &ldquo;flattens&rdquo; the frequencies and makes it much harder to do frequency analysis, which is why this cipher was considered &ldquo;unbreakable&rdquo; for 300+ years and got the nickname
&ldquo;le chiffre ind√©chiffrable&rdquo; (&ldquo;the unbreakable cipher&rdquo;).
Nevertheless, Charles Babbage cracked the Vigen√®re cipher in 1854 (though he did not publish it).
In 1863 Friedrich Kasiski broke the cipher and published the result.
The idea is that once you guess the length of the cipher, you can reduce the task to breaking a simple substitution cipher which can be done via frequency
analysis (can you see why?).
Confederate generals used Vigen√®re regularly during the civil war, and their messages were routinely cryptanalyzed by Union officers.</p>
<p><img src="/figure/confederate_cipher_disk.jpg"
	
	
	
	loading="lazy"
	
		alt="Confederate Cipher Disk for implementing the Vigen√®re cipher"
	
	
>{#tmplabelfig .margin}</p>
<p><img src="/figure/confederate_message.jpg"
	
	
	
	loading="lazy"
	
		alt="Confederate encryption of the message &ldquo;Gen&rsquo;l Pemberton: You can expect no help from this side of the river. Let Gen&rsquo;l Johnston know, if possible, when you can attack the same point on the enemy&rsquo;s lines. Inform me also and I will endeavor to make a diversion. I have sent some caps. I subjoin a despatch from General Johnston.&rdquo;"
	
	
>{#tmplabelfig .margin}</p>
<p>The <em>Enigma</em> cipher was a mechanical cipher (looking like a typewriter, see <a class="link" href="" >enigmafig</a>{.ref}) where each letter typed would get mapped into a different letter depending on the (rather complicated) key and current state
of the machine which had several rotors that rotated at different paces. An identically wired machine at the other end could be used to decrypt.
Just as many ciphers in history, this has also been believed by the Germans to be &ldquo;impossible to break&rdquo; and even quite late in the war they refused to believe it was broken despite
mounting evidence to that effect. (In fact, some German generals refused to believe it was broken even <em>after</em> the war.)
Breaking Enigma was an heroic effort which was initiated by the Poles and then completed by the British at Bletchley Park, with Alan Turing (of the Turing machines) playing a key role.
As part of this effort the Brits built arguably the world&rsquo;s first large scale mechanical computation devices (though they looked more similar to washing machines than to iPhones).
They were also helped along the way by some quirks and errors of the German operators.
For example, the fact that their messages ended with &ldquo;Heil Hitler&rdquo; turned out to be quite useful.</p>
<p><img src="/figure/enigma.jpg"
	
	
	
	loading="lazy"
	
		alt="In the Enigma mechanical cipher the secret key would be the settings of the rotors and internal wires. As the operator types up their message, the encrypted version appeared in the display area above, and the internal state of the cipher was updated (and so typing the same letter twice would generally result in two different letters output). Decrypting follows the same process: if the sender and receiver are using the same key then typing the ciphertext would result in the plaintext appearing in the display."
	
	
>{#enigmafig .margin  }</p>
<p>Here is one entertaining anecdote: the Enigma machine would never map a letter to itself.
In March 1941, Mavis Batey, a cryptanalyst at Bletchley Park received a very long message that she tried to decrypt.
She then noticed a curious property&mdash; the message did <em>not</em> contain the letter &ldquo;L&rdquo;.<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>
She realized that the probability that no &ldquo;L&rdquo;&rsquo;s appeared in the message is too small for this to happen by chance.
Hence she surmised that the original message must have been composed <em>only</em> of L&rsquo;s.
That is, it must have been the case that the operator, perhaps to test the machine, have simply sent out a message where he repeatedly pressed the letter &ldquo;L&rdquo;.
This observation helped her decode the next message, which helped inform of a planned Italian attack and secure a resounding British victory in what became known as &ldquo;the Battle of Cape Matapan&rdquo;.
Mavis also helped break another Enigma machine.
Using the information she provided, the Brits were able to feed the Germans with the false information that the main allied invasion would take place in Pas de Calais rather than on Normandy.</p>
<p>In the words of General Eisenhower, the intelligence from Bletchley park was of &ldquo;priceless value&rdquo;.
It made a huge difference for the Allied war effort, thereby shortening World War II and saving millions of lives.
See also <a class="link" href="http://www.cix.co.uk/~klockstone/hinsley.htm"  target="_blank" rel="noopener"
    >this interview with Sir Harry Hinsley</a>.</p>
<h2 id="defining-encryptions">Defining encryptions
</h2><p>Many of the troubles that cryptosystem designers faced over history (and still face!) can be attributed to not properly defining or understanding what the goals they want to achieve are in the first place.
We now turn to actually defining what is an encryption scheme. Clearly we can encode every message as a string of bits, i.e., an element of ${0,1}^\ell$ for
some $\ell$. Similarly, we can encode the <em>key</em> as a string of bits as well, i.e., an element of ${0,1}^n$ for some $n$. Thus, we can think of an encryption scheme as composed of two functions. The <em>encryption function</em> $E$ maps a secret key $k \in {0,1}^n$ and a message (known also as <em>plaintext</em>) $m\in {0,1}^\ell$ into a <em>ciphertext</em> $c \in {0,1}^L$ for some $L$. We write this as $c = E_k(m)$.
The <em>decryption function</em> $D$ does the reverse operation, mapping the secret key $k$ and the ciphertext $c$ back into the plaintext message $m$, which we write as $m = D_k(c)$.
The basic equation is that if we use the same key for encryption and decryption, then we should get the same message back.
That is, for every $k \in {0,1}^n$ and $m\in {0,1}^\ell$,</p>
<p>$$ m = D_k(E_k(m)) ;.$$</p>
<p>This motivates the following definition which attempts to capture what it means for an encryption scheme to be <em>valid</em> or &ldquo;make sense&rdquo;, regardless of whether or not it is <em>secure</em>:</p>
<p>::: {.definition title=&ldquo;Valid encryption scheme&rdquo; #encryptiondef}
Let $\ell:\N \rightarrow \N$ and $C:\N \rightarrow \N$ be two functions mapping natural numbers to natural numbers.
A pair of polynomial-time computable functions $(E,D)$ mapping strings to strings is a <em>valid private key encryption scheme</em> (or <em>encryption scheme</em> for short) with plaintext length function $\ell(\cdot)$ and ciphertext length
function $C(\cdot)$ if for every $n\in \N$, $k\in {0,1}^n$ and $m \in {0,1}^{\ell(n)}$, $|E_k(m)|= C(n)$ and
$$
D(k,E(k,m))=m ;. \label{eqvalidenc}
$$
:::</p>
<p>We will often write the first input (i.e., the key) to the encryption and decryption as a subscript and so can write <a class="link" href="" >eqvalidenc</a>{.eqref} also as $D_k(E_k(m))=m$.</p>
<p><img src="/figure/valid_encryption_fig.png"
	
	
	
	loading="lazy"
	
		alt="A private-key encryption scheme is a pair of algorithms $E,D$ such that for every key $k\in \{0,1\}^n$ and plaintext $x\in \{0,1\}^{\ell(n)}$, $c=E_k(m)$ is a ciphertext of length $C(n)$. The encryption scheme is valid if for every such $y$, $D_k(y)=x$. That is, the decryption of an encryption of $x$ is $x$, as long as both encryption and decryption use the same key."
	
	
>{#validencryption}</p>
<p>The validity condition implies that for any fixed $k$, the map $m \mapsto E_k(m)$ is one to one (can you see why?) and hence the ciphertext length is always at least the plaintext length. Thus we typically focus on the plaintext length as the quantity to optimize in an encryption scheme.
The <em>larger</em> $\ell(n)$ is, the better the scheme, since it means we need a shorter secret key to protect messages of the same length.</p>
<p>::: {.remark title=&ldquo;A note on notation, and comparison with Katz-Lindell, Boneh-Shoup, and other texts.&rdquo; #notation}
<em>A note on notation:</em> We will always use $i,j,\ell,n$ to denote natural
numbers.</p>
<p>The number $n$ will often denote the length of our secret key.
The length of the key (or another closely related number) is often known as the <em>security parameter</em> in the literature. Katz-Lindell also uses $n$ to denote this parameter, while Boneh-Shoup and Rosulek use $\lambda$ for it. (Some texts also use the Greek letter $\kappa$ for the same parameter.)
We chose to denote the security parameter by $n$ as to correspond with the standard algorithmic notation for input length (as in $O(n)$ or $O(n^2)$ time algorithms).</p>
<p>We often use $\ell$ to denote the length of the message, sometimes also known as &ldquo;block length&rdquo; since longer
messages are simply chopped into &ldquo;blocks&rdquo; of length $\ell$ and also appropriately padded.</p>
<p>We will use $k$ to denote the secret key, $m$ to denote the secret plaintext message, and $c$ to denote the encrypted ciphertext.
Note that $k,m,c$ are not numbers but rather bit strings of lengths $n,\ell(n),C(n)$
respectively. We will also sometimes use $x$ and $y$ to denote strings, and so sometimes use $x$ as the plaintext and $y$ as the ciphertext.
In general, while we try to reserve variable names for particular purposes, cryptography uses so many concepts that it would sometimes need to &ldquo;reuse&rdquo; the same letter for different purposes.</p>
<p>For simplicity, we denote the space of possible keys as ${0,1}^n$ and the space of possible messages as ${0,1}^\ell$ for $\ell=\ell(n)$. Boneh-Shoup uses a more general notation of $\mathcal{K}$ for the space of all possible keys and $\mathcal{M}$ for the space of all possible messages. This does not make much difference since we can represent every discrete object such as a key or message as a binary string. (One difference is that in principle the space of all possible messages could include messages of unbounded length, though in such a case what is done in both theory and practice is to break these up into finite-size blocks and encrypt one block at a time.)
:::</p>
<h2 id="defining-security-of-encryption">Defining security of encryption
</h2><p><a class="link" href="" >encryptiondef</a>{.ref} says nothing about security and does not rule out trivial &ldquo;encryption&rdquo; schemes such as the scheme $E_k(m) = m$ that simply outputs the plaintext as is.
Defining security is tricky, and we&rsquo;ll take it one step at a time, but let&rsquo;s start by pondering what is secret and what is not.
A priori we are thinking of an attacker Eve that simply sees the ciphertext $c=E_k(m)$ and does not know anything on how it was generated. So, it does not know the details of $E$ and $D$, and certainly does not know the secret key $k$.
However, many of the troubles past cryptosystems went through were caused by them relying on &ldquo;security through obscurity&rdquo;&mdash; trusting that the fact their <em>methods</em> are not known to their enemy will protect them from being broken.
This is a faulty assumption - if you reuse a method again and again (even with a different key each time) then eventually your adversaries will figure out what you are doing.
And if Alice and Bob meet frequently in a secure location to decide on a new method, they might as well take the opportunity to exchange their secret messages&hellip;</p>
<p>These considerations led Auguste Kerckhoffs in 1883 to state the following principle:</p>
<blockquote>
<p><em>A cryptosystem should be secure even if everything about the system, except the key, is public knowledge.</em>^[The actual quote is &ldquo;Il faut qu‚Äôil n‚Äôexige pas le secret, et qu‚Äôil puisse sans inconv√©nient tomber entre les mains de l‚Äôennemi&rdquo; loosely translated as &ldquo;The system must not require secrecy and can be stolen by the enemy without causing trouble&rdquo;. According to Steve Bellovin the NSA version is &ldquo;assume that the first copy of any device we make is shipped to the Kremlin&rdquo;.]</p>
</blockquote>
<p>Why is it OK to assume the key is secret and not the algorithm? Because we can always choose a fresh key.
But of course that won&rsquo;t help us much if our key is &ldquo;1234&rdquo; or &ldquo;passw0rd!&rdquo;.
In fact, if you use <em>any</em> deterministic algorithm to choose the key then eventually your adversary will figure this out.
Therefore for security we must choose the key at <em>random</em> and can restate Kerckhoffs&rsquo;s principle as follows:</p>
<blockquote>
<p><em>There is no secrecy without randomness</em></p>
</blockquote>
<p>This is such a crucial point that is worth repeating:</p>
<blockquote>
<p><em>There is no secrecy without randomness</em></p>
</blockquote>
<p>At the heart of every cryptographic scheme there is a secret key, and the secret key is always chosen at random.
A corollary of that is that to understand cryptography, you need to know some probability theory.
Fortunately, we don&rsquo;t need much of probability- only probability over finite spaces, and basic notions such as expectation,
variance, concentration and the union bound suffice for most of we need.
In fact, understanding the following two statements will already get you much of what you need for cryptography:</p>
<ul>
<li>
<p>For every fixed string $x\in{0,1}^n$, if you toss a coin $n$ times, the probability that the heads/tails pattern will be exactly $x$ is $2^{-n}$.</p>
</li>
<li>
<p>A probability of $2^{-128}$ is really really small.</p>
</li>
</ul>
<h3 id="generating-randomness-in-actual-cryptographic-systems">Generating randomness in actual cryptographic systems
</h3><p>How do we actually get random bits in actual systems? The main idea is to use a two stage approach. First we need to get some data that is <em>unpredictable</em> from the point of view of an attacker on our system.
Some sources for this could be measuring latency on the network or hard drives (getting harder with solid state disk), user keyboard and mouse movement patterns (problematic when you need fresh randomness at boot time
), clock drift and more, there are some other sources including audio, video, and network. All of these can be problematic, especially for servers or virtual machines, and so hardware based random number generators based on phenomena
such as thermal noise or nuclear decay are becoming more popular. Once we have some data $X$ that is unpredictable, we need to estimate the <em>entropy</em> in it. You can roughly imagine that $X$ has $k$ bits of entropy
if the probability that an attacker can guess $X$ is at most $2^{-k}$. People then use a <em>hash function</em> (an object we&rsquo;ll talk about more later) to map $X$ into a string of length $k$ which is then hopefully distributed
(close to) uniformly at random. All of this process, and especially understanding the amount of information an attacker may have on the entropy sources, is a bit of a dark art and indeed a number of attacks on cryptographic
systems were actually enabled by weak generation of randomness. Here are a few examples.</p>
<p>One of the first attacks was on the SSL implementation of Netscape (<em>the</em> browser at the time). Netscape used the following &ldquo;unpredictable&rdquo; information&mdash; the time of day and a process ID both of which turned out to be quite
predictable (who knew attackers have clocks too?). Netscape tried to protect its security through &ldquo;security through obscurity&rdquo; by not releasing the source code for their pseudorandom generator, but it was reverse engineered by <a class="link" href="https://www.cs.berkeley.edu/~daw/papers/ddj-netscape.html"  target="_blank" rel="noopener"
    >Ian Goldberg and David Wagner</a> (Ph.D students at the time) who demonstrated this attack.</p>
<p>In 2006 a programmer removed a line of code from the procedure to generate entropy in OpenSSL package distributed by Debian since it caused a warning in some automatic verification code. As a result for two years (until this was
discovered) all the randomness generated by this procedure used only the process ID as an &ldquo;unpredictable&rdquo; source. This means that all communication done by users in that period is fairly easily breakable (and in particular,
if some entities recorded that communication they could break it also retroactively). This caused a huge headache and a worldwide regeneration of keys, though it is believed that many of the weak keys are still used.
See <a class="link" href="http://www.xkcd.com/424/"  target="_blank" rel="noopener"
    >XKCD&rsquo;s take</a> on that incident.</p>
<p><img src="/figure/random_number.png"
	
	
	
	loading="lazy"
	
		alt="XKCD Cartoon: Random number generator"
	
	
>{#tmplabelfig .margin}</p>
<p>In 2012 two separate teams of researchers scanned a large number of RSA keys on the web and found out that about 4 percent of them are easy to break.
The main issue were devices such as routers, internet-connected printers and such. These devices sometimes run variants of Linux- a desktop operating system- but without a hard drive, mouse or keyboard, they don&rsquo;t have access to many of the entropy sources that desktops have. Coupled with some good old fashioned ignorance of cryptography and software bugs, this led to many keys that are downright trivial
to break, see <a class="link" href="https://freedom-to-tinker.com/blog/nadiah/new-research-theres-no-need-panic-over-factorable-keys-just-mind-your-ps-and-qs/"  target="_blank" rel="noopener"
    >this blog post</a> and <a class="link" href="https://factorable.net/"  target="_blank" rel="noopener"
    >this web page</a> for more details.</p>
<p>After the entropy is collected and then &ldquo;purified&rdquo; or &ldquo;extracted&rdquo; to a uniformly random string that is, say, a few hundred bits long, we often need to &ldquo;expand&rdquo; it into a longer string that is also uniform (or at least looks like that for all practical purposes). We will discuss how to go about that in the next lecture. This step has its weaknesses too, and in particular the Snowden documents, combined with observations of Shumow and Ferguson, strongly suggest that the NSA has deliberately inserted a <em>trapdoor</em> in one of the pseudorandom generators published by the National Institute of Standards and Technologies (NIST).
Fortunately, this generator wasn&rsquo;t widely adopted, but apparently the NSA did pay 10 million dollars to RSA security so the latter would make this generator their default option in their products.</p>
<h2 id="defining-the-secrecy-requirement">Defining the secrecy requirement.
</h2><p>Defining the secrecy requirement for an encryption is not simple.
Over the course of history, many smart people got it wrong and convinced themselves that ciphers were impossible to break.
The first person to truly ask the question in a rigorous way was Claude Shannon
in 1945 (though a partial version of his manuscript was only declassified in 1949).
Simply by asking this question, he made an enormous contribution to the science of cryptography and practical security.
We now will try to examine how one might answer it.</p>
<p>Let me warn you ahead of time that we are going to insist on a <em>mathematically precise definition</em> of security.
That means that the definition must capture security in all cases, and the existence of a single counterexample, no matter how &ldquo;silly&rdquo;, would make us rule out a candidate definition.
This exercise of coming up with &ldquo;silly&rdquo; counterexamples might seem, well, silly.
But in fact it is this method that has led Shannon to formulate his theory of secrecy, which (after much followup work) eventually revolutionized cryptography, and brought this science to a new age where Edgar Allan Poe&rsquo;s maxim no longer holds, and we are able to design ciphers which human (or even nonhuman) ingenuity cannot break.</p>
<p>The most natural way to attack an encryption is for Eve to guess all possible keys.
In many encryption schemes this number is enormous and this attack is completely infeasible.
For example, the theoretical number of possibilities in the Enigma cipher was about $10^{113}$ which roughly means that even if we filled the milky way galaxy with computers operating at light speed, the sun would still die out before it finished examining all the possibilities.<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> One can understand why the Germans thought it was impossible to break. (Note that despite the number of possibilities being so enormous, such a key can still be easily specified and shared between Alice and Bob by writing down $113$ digits on a piece of paper.)
Ray Miller of the NSA had calculated that, in the way the Germans used the machine, the number of possibilities was &ldquo;only&rdquo; $10^{23}$, but this is still extremely difficult to pull off even today, and many orders of magnitudes above the computational powers during the WW-II era.
Thus clearly, it is sometimes possible to break an encryption without trying all possibilities.
A corollary is that having a huge number of key combinations does not guarantee security, as an attacker might find a shortcut (as the allies did for Enigma) and recover the key without trying all options.</p>
<p>Since it is possible to recover the key with some tiny probability (e.g. by guessing it at random), perhaps one way to define security of an encryption scheme is that an attacker can never recover the key with probability significantly higher than that.
Here is an attempt at such a definition:</p>
<blockquote>
<h1 id="securefirstattemptdef">
</h1></blockquote>
<p>An encryption scheme $(E,D)$ is
<em>$n$-secure</em> if no matter what method Eve employs, the probability that she
can recover the true key $k$ from the ciphertext $c$ is at most $2^{-n}$.</p>
<p>::: { .pause }
When you see a mathematical definition that attempts to model some real-life phenomenon such as security, you should pause and ask yourself:</p>
<ol>
<li>
<p>Do I understand mathematically what the definition is stating? \</p>
</li>
<li>
<p>Is it a reasonable way to capture the real life phenomenon we are discussing?</p>
</li>
</ol>
<p>One way to answer question 2 is to try to think of both examples of objects that satisfy the definition and examples of objects that violate it, and see if this conforms to your intuition about whether these objects display the phenomenon we are trying to capture. Try to do this for <a class="link" href="" >securefirstattemptdef</a>{.ref}
:::</p>
<p>You might wonder if <a class="link" href="" >securefirstattemptdef</a>{.ref} is not <em>too strong</em>.
After all how are we going to ever prove that Eve cannot recover the secret key no matter what she does? Edgar Allan Poe would say that there can always be a method that we overlooked. However, in fact this definition is too <em>weak</em>! Consider the following encryption: the secret key $k$ is chosen at random in ${0,1}^n$ but our encryption scheme simply ignores it and lets $E_k(m)=m$ and $D_k(c)=c$. This is a valid encryption since $D_k(E_k(m))=m$, but is of course completely insecure as we are simply outputting the plaintext in the clear.
Yet, no matter what Eve does, if she only sees $c$ and not $k$, there is no way she can guess the true value of $k$ with probability better than $2^{-n}$, since it was chosen completely at random and she gets no information about it.
Formally, one can prove the following result:</p>
<blockquote>
<h1 id="trivialsec">
</h1></blockquote>
<p>Let $(E,D)$ be the encryption scheme above. For every function $Eve:{0,1}^\ell\rightarrow {0,1}^n$ and for every $m\in {0,1}^\ell$, the probability that
$Eve(E_k(m))=k$ is exactly $2^{-n}$.</p>
<blockquote>
<h1 id="heading">
</h1></blockquote>
<p>This follows because $E_k(m)=m$ and hence $Eve(E_k(m))=Eve(m)$ which is some fixed value $k&rsquo;\in{0,1}^n$ that is independent
of $k$. Hence the probability that $k=k&rsquo;$ is $2^{-n}$. QED</p>
<p>The math behind the above argument is very simple, yet I urge you to read and re-read the last two paragraphs until you are sure that
you completely understand why this encryption is in fact secure according to the above definition.
This is a &ldquo;toy example&rdquo; of the kind of reasoning that we will be employing constantly throughout this course,
and you want to make sure that you follow it.</p>
<p>So, <a class="link" href="" >trivialsec</a>{.ref} is true, but one might question its meaning.
Clearly this silly example was not what we meant when stating this definition.
However, as mentioned above, we are not willing to ignore even silly examples and must amend the definition to rule them out.
One obvious objection is that we don&rsquo;t care about hiding the key- it is the <em>message</em> that we are trying to keep secret.
This suggests the next attempt:</p>
<blockquote>
<h1 id="securesecondattemptdef">
</h1></blockquote>
<p>An encryption scheme $(E,D)$ is <em>$n$-secure</em> if for every message $m$ no matter what method Eve employs, the
probability that she can recover $m$ from the ciphertext $c=E_k(m)$ is at most $2^{-n}$.</p>
<p>Now this seems like it captures our intended meaning. But remember that we are being anal, and truly insist that the definition holds
as stated, namely that for every plaintext message $m$ and every function $Eve:{0,1}^C\rightarrow{0,1}^\ell$, the probability over the choice of $k$
that $Eve(E_k(m))=m$ is at most $2^{-n}$. But now we see that this is clearly impossible. After all, this is supposed to work for
<em>every</em> message $m$ and <em>every</em> function $Eve$, but clearly if $m$ is the all-zeroes message $0^\ell$ and $Eve$ is the function that ignores its input
and simply outputs $0^\ell$, then it will hold that $Eve(E_k(m))=m$ with probability one.</p>
<p>So, if before the definition was too weak, the new definition is too strong and is impossible to achieve.
The problem is that of course we could guess a fixed message with probability one, so perhaps we could try to consider a definition with a <em>random</em> message. That is:</p>
<blockquote>
<h1 id="securethirdattemptdef">
</h1></blockquote>
<p>An encryption scheme $(E,D)$ is <em>$n$-secure</em> if no matter what method Eve employs, if $m$ is chosen at random
from ${0,1}^\ell$, the probability that she can recover $m$ from the ciphertext
$c=E_k(m)$ is at most $2^{-n}$.</p>
<p>This weakened definition can in fact be achieved, but we have again weakened it too much.
Consider an encryption that hides the last $\ell/2$ bits of the
message, but completely reveals the first $\ell/2$ bits.
The probability of guessing a random message is $2^{-\ell/2}$, and so such a scheme would be &ldquo;$\ell/2$ secure&rdquo; per <a class="link" href="" >securethirdattemptdef</a>{.ref} but this is still a scheme that
you would not want to use.
The point is that in practice we don&rsquo;t encrypt random messages&mdash; our messages might be in English, might have
common headers, and might have even more structures based on the context.
In fact, it may be that the message is either &ldquo;Yes&rdquo; or &ldquo;No&rdquo; (or perhaps either
&ldquo;Attack today&rdquo; or &ldquo;Attack tomorrow&rdquo;) but we want to make sure Eve doesn&rsquo;t
learn which one it is.
So, using an encryption scheme that reveals the first half of the message (or frankly even only the first bit) is unacceptable.</p>
<h2 id="perfect-secrecy">Perfect Secrecy
</h2><p>So far all of our attempts at definitions oscillated between being too strong
(and hence impossible) or too weak (and hence not guaranteeing actual
security).
The key insight of Shannon was that in a secure encryption scheme
the ciphertext should not reveal <em>any additional information</em> about the
plaintext. So, if for example it was a priori possible for Eve to guess the
plaintext with some probability $1/k$ (e.g., because there were only $k$
possibilities for it) then she should not be able to guess it with higher
probability after seeing the ciphertext.
This can be formalized as follows:</p>
<p>::: {.definition title=&ldquo;Perfect secrecy&rdquo; #perfectsecrecydef}
An encryption scheme $(E,D)$ is <em>perfectly secret</em> if there for every set $M\subseteq{0,1}^\ell$ of plaintexts,
and for every strategy used by Eve, if we choose at random $m\in M$ and a
random key $k\in{0,1}^n$, then the probability that Eve guesses $m$ after
seeing $E_k(m)$ is at most $1/|M|$.
:::</p>
<p>In particular, if we encrypt either &ldquo;Yes&rdquo; or &ldquo;No&rdquo; with probability $1/2$, then Eve won&rsquo;t be able to guess which one it is with probability better than half.
In fact, that turns out to be the heart of the matter:</p>
<p>::: {.theorem title=&ldquo;Two to many theorem&rdquo; #twotomanythm}
An encryption scheme $(E,D)$ is perfectly secret if and only if for every two distinct plaintexts ${m_0,m_1} \subseteq {0,1}^\ell$ and every strategy used by Eve, if we choose at random $b\in{0,1}$ and a random key $k\in{0,1}^n$, then the probability that Eve guesses $m_b$ after seeing $E_k(m_b)$ is at most $1/2$.
:::</p>
<p>::: {.proof data-ref=&ldquo;twotomanythm&rdquo;}
The &ldquo;only if&rdquo; direction is obvious&mdash; this condition is a special case of the perfect secrecy condition for a set $M$ of size $2$.</p>
<p>The &ldquo;if&rdquo; direction is trickier. We will use a proof by contradiction. We need to show that if there is
some set $M$ (of size possibly much larger than $2$) and some strategy for Eve
to guess (based on the ciphertext) a plaintext chosen from $M$ with probability larger than $1/|M|$, then
there is also some set $M&rsquo;$ of size two and a strategy $Eve&rsquo;$ for Eve to guess a plaintext
chosen from $M&rsquo;$ with probability larger than $1/2$.</p>
<p>Let&rsquo;s fix the message $m_0$ to be the all zeroes message and pick $m_1$ at random in $M$.
Under our assumption, it holds that for random key $k$ and message $m_1\in M$,
$$\Pr_{k \leftarrow_R {0,1}^n, m_1 \leftarrow_R M}[Eve(E_k(m_1))=m_1] &gt; 1/|M|;. \label{eqabovetrivialcipher}$$
On the other hand, for every choice of $k$, $m&rsquo;= Eve(E_k(m_0))$ is a fixed string independent on the choice of $m_1$, and so if we pick $m_1$ at random in $M$, then the probability that $m_1=m&rsquo;$ is at most $1/|M|$, or in other words</p>
<p>$$\Pr_{k \leftarrow_R {0,1}^n, m_1 \leftarrow_R M}[Eve(E_k(m_0))=m_1] \leq 1/|M|;. \label{eqhitcipher}$$</p>
<p>We can also write <a class="link" href="" >eqabovetrivialcipher</a>{.eqref} and <a class="link" href="" >eqhitcipher</a>{.eqref} as
$$
\E_{m_1 \leftarrow_R M} \Pr[ Eve(E_k(m_1))=m_1] &gt; 1/|M|
$$
and
$$
\E_{m_1 \leftarrow_R M} \Pr[ Eve(E_k(m_0))=m_1] \leq 1/|M|
$$
where these expectations are taken over the choice of $m_1$.
Hence by linearity of expectation
$$
\E_{m_1 \leftarrow_R M} \left( \Pr[ Eve(E_k(m_1))=m_1] - \Pr[ Eve(E_k(m_0))=m_1] \right) &gt; 0 ;. \label{eqadvantageciphermonevsmzero}
$$
(In words, for random $m_1$, the probability that Eve outputs $m_1$ given an encryption of $m_1$ is higher than the probability that Eve outputs $m_1$ given an encryption of $m_0$.)</p>
<p>In particular, by the <em>averaging argument</em> (the argument that if the average of numbers is larger than $\alpha$ then one of the numbers is larger than $\alpha$) there must <em>exist</em> $m_1 \in M$ satisfying
$$ \Pr[Eve(E_k(m_1))=m_1] &gt; \Pr[Eve(E_k(m_0))=m_1] ;.$$
(Can you see why? This is worthwhile stopping and reading again.)</p>
<p>But this can be turned into an attacker $Eve&rsquo;$ such that for $b \leftarrow_R {0,1}$.
the probability that $Eve&rsquo;(E_k(m_b))=m_b$ is larger than $1/2$.
Indeed, we can define $Eve&rsquo;(c)$ to output $m_1$ if $Eve(c)=m_1$ and otherwise
output a random message in ${ m_0 , m_1 }$.
The probability that $Eve&rsquo;(y)$ equals $m_1$ is higher when $c=E_k(m_1)$ than when $c=E_k(m_0)$, and since
$Eve&rsquo;$ outputs either $m_0$ or $m_1$, this means that the probability
that $Eve&rsquo;(E_k(m_b))=m_b$ is larger than $1/2$. (Can you see why?)
:::</p>
<blockquote>
<h1 id="heading-1">
</h1></blockquote>
<p>The proof of <a class="link" href="" >twotomanythm</a>{.ref} is not trivial, and is worth reading again and making sure you understand it.
An excellent exercise, which I urge you to pause and do now is to prove the following:
$(E,D)$ is perfectly secret if for every plaintexts $m,m&rsquo; \in {0,1}^\ell$, the two
random variables ${ E_k(m) }$ and ${ E_{k&rsquo;}(m&rsquo;) }$ (for randomly chosen keys $k$ and $k&rsquo;$)
have precisely the same distribution.</p>
<p>::: {.solvedexercise title=&ldquo;Perfect secrecy, equivalent definition&rdquo; #perfectsecrecyequiv}
Prove that a valid encryption scheme $(E,D)$ with plaintext length $\ell(\cdot)$ is perfectly secret if and only if for every $n\in \N$ and plaintexts $m,m&rsquo; \in {0,1}^{\ell(n)}$, the following two distributions $Y$ and $Y&rsquo;$ over ${0,1}^*$ are identical:</p>
<ul>
<li>
<p>$Y$ is obtained by sampling $k\leftarrow_R {0,1}^n$ and outputting $E_k(m)$.</p>
</li>
<li>
<p>$Y&rsquo;$ is obtained by sampling $k\leftarrow_R {0,1}^n$ and outputting $E_k(m&rsquo;)$.
:::</p>
</li>
</ul>
<p>::: {.solution data-ref=&ldquo;perfectsecrecyequiv&rdquo;}
We only sketch the proof. The condition in the exercise is equivalent to perfect secrecy with $|M|=2$.
For every $M = { m,m&rsquo; }$, if $Y$ and $Y&rsquo;$ are identical then clearly for every $Eve$ and possible output $y$, $\Pr[ Eve(E_k(m))=y] = \Pr[ Eve(E_k(m&rsquo;))=y]$ since these correspond applying $Eve$ on the same distribution $Y=Y&rsquo;$.
On the other hand, if $Y$ and $Y&rsquo;$ are not identical then there must exist some ciphertext $c^<em>$ such that $\Pr[ Y=c^</em>] &gt; \Pr[ Y&rsquo;=c^<em>]$ (or vice versa).
The adversary that on input $c$ guesses that $c$ is an encryption of $m$ if $c=c^</em>$ and otherwise tosses a coin will have some advantage over $1/2$ in distinguishing an encryption of $m$ from an encryption of $m&rsquo;$.
:::</p>
<p>We summarize the equivalent definitions of perfect secrecy in the following theorem, whose (omitted) proof follows from <a class="link" href="" >twotomanythm</a>{.ref} and <a class="link" href="" >perfectsecrecyequiv</a>{.ref} as well as similar proof ideas.</p>
<p>::: {.theorem title=&ldquo;Perfect secrecy equivalent conditions&rdquo; #perfectsecrecythm}
Let $(E,D)$ be a valid encryption scheme with message length $\ell(n)$. Then the following conditions are equivalent:</p>
<ol>
<li>
<p>$(E,D)$ is perfectly secret as per <a class="link" href="" >perfectsecrecydef</a>{.ref}.</p>
</li>
<li>
<p>For every pair of messages $m_0,m_1 \in {0,1}^{\ell(n)}$, the distributions ${ E_k(m_0) }<em>{k \leftarrow_R {0,1}^n}$ and ${ E_k(m_1) }</em>{k \leftarrow_R {0,1}^n}$ are identical.</p>
</li>
<li>
<p>(Two-message security: Eve can&rsquo;t guess which of one of two messages was encrypted with success better than half.) For every function $Eve:{0,1}^{C(n)} \rightarrow {0,1}^{\ell(n)}$ and pair of messages $m_0,m_1 \in {0,1}^{\ell(n)}$,</p>
</li>
</ol>
<p>$$\Pr_{b \leftarrow_R {0,1}, k \leftarrow_R {0,1}^n} [ Eve(E_k(m_b))=m_b ] \leq 1/2$$</p>
<ol start="4">
<li>(Arbitrary prior security: Eve can&rsquo;t guess which message was encrypted with success better than her prior information.) For every distribution $\mathcal{D}$ over ${0,1}^{\ell(n)}$, and $Eve:{0,1}^{C(n)} \rightarrow {0,1}^{\ell(n)}$,</li>
</ol>
<p>$$\Pr_{m \leftarrow_R \mathcal{D}, k \leftarrow_R {0,1}^n}[ Eve(E_k(m))=m ] \leq \max(\mathcal{D})$$</p>
<p>where we denote $\max(\mathcal{D}) = \max_{m^<em>\in {0,1}^{\ell(n)}} \Pr_{m \leftarrow_R \mathcal{D}}[m=m^</em>]$ to be the largest probability of any element under $\mathcal{D}$.
:::</p>
<h3 id="achieving-perfect-secrecy">Achieving perfect secrecy
</h3><p>So, perfect secrecy is a natural condition, and does not seem to be too weak for applications, but can it actually
be achieved? After all, the condition that two different plaintexts are mapped to the same distribution seems somewhat at odds
with the condition that Bob would succeed in decrypting the ciphertexts and find out if the plaintext was in fact $m$ or $m&rsquo;$.
It turns out the answer is yes! For example, <a class="link" href="" >onetimepadtwofig</a>{.ref} details a perfectly secret
encryption for two bits.</p>
<p><img src="/figure/onetimepadtwobits.png"
	
	
	
	loading="lazy"
	
		alt="A perfectly secret encryption scheme for two-bit keys and messages. The blue vertices represent plaintexts and the red vertices represent ciphertexts, each edge mapping a plaintext $m$ to a ciphertext $c=E_k(m)$ is labeled with the corresponding key $k$. Since there are four possible keys, the degree of the graph is four and it is in fact a complete bipartite graph. The encryption scheme is valid in the sense that for every $k\in \{0,1\}^2$, the map $m \mapsto E_k(m)$ is one-to-one, which in other words means that the set of edges labeled with $k$ is a matching."
	
	
>{#onetimepadtwofig  }</p>
<p>In fact, this can be generalized to any number of bits:^[The one-time pad is typically credited to Gilbert Vernam of Bell and Joseph Mauborgne of the U.S. Army Signal Corps, but Steve Bellovin discovered an earlier inventor <a class="link" href="http://www.cs.columbia.edu/~CS4HS/talks/FrankMillerOneTimePad.pdf"  target="_blank" rel="noopener"
    >Frank Miller</a> who published a description of the one-time pad in 1882. However, it is unclear if Miller realized the fact that security of this system can be mathematically proven, and so the theorem below should probably be still be credited to Vernam and Mauborgne.]</p>
<blockquote>
<h1 id="onetimepad">
</h1></blockquote>
<p>There is a perfectly secret valid encryption scheme $(E,D)$ with $\ell(n)=n$.</p>
<blockquote>
<h1 id="heading-2">
</h1></blockquote>
<p>Our scheme is the <a class="link" href="https://en.wikipedia.org/wiki/One-time_pad"  target="_blank" rel="noopener"
    >one-time pad</a> also known as the &ldquo;Vernam Cipher&rdquo;, see <a class="link" href="" >onetimepadfig</a>{.ref}.
The encryption is exceedingly simple: to encrypt a message $m\in {0,1}^n$ with a key $k \in {0,1}^n$ we simply output $m \oplus k$ where $\oplus$ is the bitwise XOR operation that outputs the string corresponding to XORing each coordinate of $m$ and $k$.</p>
<p><img src="/figure/onetimepad.png"
	
	
	
	loading="lazy"
	
		alt="In the one time pad encryption scheme we encrypt a plaintext $m\in \{0,1\}^n$ with a key $k\in \{0,1\}^n$ by the ciphertext $m \oplus k$ where $\oplus$ denotes the bitwise XOR operation."
	
	
>{#onetimepadfig  }</p>
<p>::: {.proof data-ref=&ldquo;onetimepad&rdquo;}
For two binary strings $a$ and $b$ of the same length $n$, we define $a \oplus b$ to be the string $c \in {0,1}^n$ such that $c_i = a_i + b_i \mod 2$ for every $i\in [n]$.
The encryption scheme $(E,D)$ is defined as follows: $E_k(m) = m\oplus k$ and $D_k(c)= c \oplus k$.
By the associative law of addition (which works also modulo two), $D_k(E_k(m))=(m\oplus k) \oplus k = m \oplus (k \oplus k) = m \oplus 0^n = m$,
using the fact that for every bit $\sigma \in {0,1}$, $\sigma + \sigma \mod 2 = 0$ and $\sigma + 0 = \sigma \mod 2$.
Hence $(E,D)$ form a valid encryption.</p>
<p>To analyze the perfect secrecy property, we claim that for every $m\in {0,1}^n$, the distribution $Y_m=E_k(m)$ where $k \leftarrow_R {0,1}^n$ is simply the uniform distribution over ${0,1}^n$, and hence in particular the distributions $Y_{m}$ and $Y_{m&rsquo;}$ are identical for every $m,m&rsquo; \in {0,1}^n$.
Indeed, for every particular $y\in {0,1}^n$, the value $y$ is output by $Y_m$ if and only if $y = m \oplus k$ which holds if and only if $k= m \oplus y$. Since $k$ is chosen uniformly at random in ${0,1}^n$, the probability that $k$ happens to equal $m \oplus y$ is exactly $2^{-n}$, which means that every string $y$ is output by $Y_m$ with probability $2^{-n}$.
:::</p>
<p><img src="/figure/perfectsecrecy.png"
	
	
	
	loading="lazy"
	
		alt="For any key length $n$, we can visualize an encryption scheme $(E,D)$ as a graph with a vertex for every one of the $2^{\ell(n)}$ possible plaintexts and for every one of the ciphertexts in $\{0,1\}^*$ of the form $E_k(x)$ for $k\in \{0,1\}^n$ and $x\in \{0,1\}^{\ell(n)}$. For every plaintext $x$ and key $k$, we add an edge labeled $k$ between $x$ and $E_k(x)$. By the validity condition, if we pick any fixed key $k$, the map $x \mapsto E_k(x)$ must be one-to-one. The condition of perfect secrecy simply corresponds to requiring that every two plaintexts $x$ and $x&rsquo;$ have exactly the same set of neighbors (or multi-set, if there are parallel edges)."
	
	
>{#perfectsecfig  }</p>
<blockquote>
<h1 id="heading-3">
</h1></blockquote>
<p>The argument above is quite simple but is worth reading again. To understand why the one-time pad is perfectly secret, it is useful to envision it as a bipartite graph as we&rsquo;ve done in <a class="link" href="" >onetimepadtwofig</a>{.ref}. (In fact the encryption scheme of <a class="link" href="" >onetimepadtwofig</a>{.ref} is precisely the one-time pad for $n=2$.) For every $n$, the one-time pad encryption scheme corresponds to a bipartite graph with $2^n$ vertices on the &ldquo;left side&rdquo; corresponding to the plaintexts in ${0,1}^n$ and $2^n$ vertices on the &ldquo;right side&rdquo; corresponding to the ciphertexts ${0,1}^n$.
For every $x\in {0,1}^n$ and $k\in {0,1}^n$, we connect $x$ to the vertex $y=E_k(x)$ with an edge that we label with $k$.
One can see that this is the complete bipartite graph, where every vertex on the left is connected to <em>all</em> vertices on the right.
In particular this means that for every left vertex $x$, the distribution on the ciphertexts obtained by taking a random $k\in {0,1}^n$ and going to the neighbor of $x$ on the edge labeled $k$ is the uniform distribution over ${0,1}^n$.
This ensures the perfect secrecy condition.</p>
<h2 id="necessity-of-long-keys">Necessity of long keys
</h2><p>So, does <a class="link" href="" >onetimepad</a>{.ref} give the final word on cryptography, and means that we can all communicate with perfect secrecy and live happily ever after?
No it doesn&rsquo;t.
While the one-time pad is efficient, and gives perfect secrecy, it has one glaring disadvantage: to communicate $n$ bits you need to store a key of length $n$.
In contrast, practically used cryptosystems such as AES-128 have a short key of $128$ bits (i.e., $16$ bytes) that can be used to protect terabytes or more of communication!
Imagine that we all needed to use the one time pad.
If that was the case, then if you had to communicate with $m$ people, you would have to maintain (securely!)
$m$ huge files that are each as long as the length of the maximum total communication you expect with that person.
Imagine that every time you opened an account with Amazon, Google, or any other service, they would need to send you in the mail (ideally with a secure courier) a DVD full of random numbers, and every time you suspected a virus, you&rsquo;d need to ask all these services for a fresh DVD. This doesn&rsquo;t sound so appealing.</p>
<p>This is not just a theoretical issue.
The Soviets have used the one-time pad for their confidential communication since before the 1940&rsquo;s.
In fact, even before Shannon&rsquo;s work, the U.S. intelligence already knew in 1941 that the one-time pad is in principle &ldquo;unbreakable&rdquo; (see page 32 in the <a class="link" href="http://nsarchive.gwu.edu/NSAEBB/NSAEBB278/01.PDF"  target="_blank" rel="noopener"
    >Venona document</a>).
However, it turned out that the hassle of manufacturing so many keys for all the communication took its toll on the Soviets and they ended up reusing the same keys
for more than one message. They did try to use them for completely different receivers in the (false) hope that this wouldn&rsquo;t be detected.
The <a class="link" href="https://en.wikipedia.org/wiki/Venona_project"  target="_blank" rel="noopener"
    >Venona Project</a> of the U.S. Army was founded in February 1943 by Gene Grabeel (see <a class="link" href="" >genegrabeelfig</a>{.ref}), a former home economics teacher from Madison Heights, Virginia and Lt. Leonard Zubko.
In October 1943, they had their breakthrough when it was discovered that the Russians were reusing their keys.
In the 37 years of its existence, the project has resulted in a treasure chest of intelligence, exposing hundreds of KGB agents and Russian spies in the U.S. and other countries,
including Julius Rosenberg, Harry Gold, Klaus Fuchs, Alger Hiss, Harry Dexter White and many others.</p>
<p><img src="/figure/genevenona.png"
	
	
	
	loading="lazy"
	
		alt="Gene Grabeel, who founded the U.S. Russian SigInt program on 1 Feb 1943. Photo taken in 1942, see Page 7 in the Venona historical study."
	
	
>{#genegrabeelfig .margin  }</p>
<p><img src="/figure/longkeygraph.png"
	
	
	
	loading="lazy"
	
		alt="An encryption scheme where the number of keys is smaller than the number of plaintexts corresponds to a bipartite graph where the degree is smaller than the number of vertices on the left side. Together with the validity condition this implies that there will be two left vertices $x,x&rsquo;$ with non-identical neighborhoods, and hence the scheme does not satisfy perfect secrecy."
	
	
>{#longkeygraphfig .margin  }</p>
<p>Unfortunately it turns out that that such long keys are <em>necessary</em> for perfect secrecy:</p>
<blockquote>
<h3 id="longkeysthm">
</h3></blockquote>
<p>For every perfectly secret encryption scheme $(E,D)$ the length function $\ell$ satisfies $\ell(n) \leq n$.</p>
<blockquote>
<h3 id="heading-4">
</h3></blockquote>
<p>The idea behind the proof is illustrated in <a class="link" href="" >longkeygraphfig</a>{.ref}. We define a graph between the plaintexts and ciphertexts, where we put an edge between plaintext $x$ and ciphertext $y$ if there is some key $k$ such that $y=E_k(x)$. The <em>degree</em> of this graph is at most the number of potential keys. The fact that the degree is smaller than the number of plaintexts (and hence of ciphertexts) implies that there would be two plaintexts $x$ and $x&rsquo;$ with different sets of neighbors, and hence the distribution of a ciphertext corresponding to $x$ (with a random key) will not be identical to the distribution of a ciphertext corresponding to $x&rsquo;$.</p>
<p>::: {.proof data-ref=&ldquo;longkeysthm&rdquo;}
Let $E,D$ be a valid encryption scheme with messages of length $\ell$ and key of length $n&lt;\ell$.
We will show that $(E,D)$ is not perfectly secret by providing two plaintexts $x_0,x_1 \in {0,1}^\ell$ such that the distributions $Y_{x_0}$ and $Y_{x_1}$ are not identical, where $Y_x$ is the distribution obtained by picking $k \leftarrow_R {0,1}^n$ and outputting $E_k(x)$.</p>
<p>We choose $x_0 = 0^\ell$.
Let $S_0 \subseteq {0,1}^*$ be the set of all ciphertexts that have nonzero probability of being output in $Y_{x_0}$. That is, $S_0={ y ;|; \exists_{k\in {0,1}^n} y=E_k(x_0) }$.
Since there are only $2^n$ keys, we know that $|S_0| \leq 2^n$.</p>
<p>We will show the following claim:</p>
<p><strong>Claim I:</strong> There exists some $x_1 \in {0,1}^\ell$ and $k\in {0,1}^n$ such that $E_k(x_1) \not\in S_0$.</p>
<p>Claim I implies that the string $E_k(x_1)$ has positive probability of being output by $Y_{x_1}$ and zero probability of being output by $Y_{x_0}$ and hence in particular $Y_{x_0}$ and $Y_{x_1}$ are not identical.
To prove Claim I, just choose a fixed $k\in {0,1}^n$. By the validity condition, the map $x \mapsto E_k(x)$ is a one to one map of ${0,1}^\ell$ to ${0,1}^*$ and hence in particular
the <em>image</em> of this map which is the set $I_k = { y ;|; \exists_{x\in {0,1}^\ell} y=E_k(x) }$ has size at least (in fact exactly) $2^\ell$.
Since $|S_0| \leq 2^n &lt; 2^\ell$, this means that $|I_k|&gt;|S_0|$ and so in particular there exists some string $y$ in $I_k \setminus S_0$. But by the definition of $I_k$ this means that there is some $x\in {0,1}^\ell$ such that $E_k(x) \not\in S_0$ which concludes the proof of Claim I and hence of <a class="link" href="" >longkeysthm</a>{.ref}.
:::</p>
<p>::: {.remark title=&ldquo;Adding probability into the picture&rdquo; #addingprobrem}
There is a sense in which both our secrecy and our impossibility results might not be fully convincing, and that is that we did not explicitly consider
algorithms that use <em>randomness</em> . For example, maybe Eve can break a perfectly secret encryption if she is not modeled as a deterministic function
$Eve:{0,1}^o\rightarrow{0,1}^\ell$ but rather a <em>probabilistic</em> process. Similarly, maybe the encryption and decryption functions could be probabilistic
processes as well. It turns out that none of those matter.</p>
<p>For the former, note that a probabilistic process can be thought of as a <em>distribution</em> over functions, in the sense that we have a collection of functions $f_1,&hellip;,f_N$ mapping ${0,1}^o$ to ${0,1}^\ell$, and some probabilities $p_1,\ldots,p_N$ (non-negative numbers summing to $1$), so we now think of Eve as selecting the function $f_i$ with probability $p_i$.
But if none of those functions can give an advantage better than $1/2$, then neither can this collection (this is related to the <em>averaging principle</em> in probability).</p>
<p>A similar (though more involved) argument shows that the impossibility result showing that the key must be at least as long as the message still holds even if the encryption and decryption algorithms are allowed to be probabilistic processes as well (working this out is a great exercise).
:::</p>
<h3 id="amplifying-success-probability">Amplifying success probability
</h3><p><a class="link" href="" >longkeysthm</a>{.ref} implies that for every encryption scheme $(E,D)$ with $\ell(n)&gt;n$, there is a pair of messages $x_0,x_1$ and an attacker $Eve$ that can distinguish between an encryption of $x_0$ and an encryption of $x_1$ with success better than $1/2$. But perhaps Eve&rsquo;s success is only marginally better than half, say $0.50001$? It turns out that&rsquo;s not the case. If the message is even somewhat larger than the key, the success of Eve can be very close to $1$:</p>
<p>::: {.theorem title=&ldquo;Short keys imply high probability attack&rdquo; #longkeyhighprob}
Let $(E,D)$ be an encryption scheme with $\ell(n)=n+t$. Then there is a function $Eve$ and pair of messages $x_0,x_1$ such that
$$\Pr_{k \leftarrow_R {0,1}^n, b \leftarrow_R {0,1}}[ Eve(E_k(x_b)) = x_b] \geq 1- 2^{-t-1};.$$
:::</p>
<p>::: {.proof data-ref=&ldquo;longkeyhighprob&rdquo;}
As in the proof of <a class="link" href="" >longkeysthm</a>{.ref}, let $\ell=\ell(n)$ and let $x_0 = 0^\ell$ and $S_0 = { E_k(x_0) : k\in {0,1}^n }$ be the set of size at most $2^n$ of all ciphertexts corresponding to $x_0$.
We claim that</p>
<p>$$\Pr_{k \leftarrow_R {0,1}^n , x \in {0,1}^\ell}[ E_k(x) \in S_0 ] \leq 2^{-t};. \label{eqlongkeyprobproof}$$</p>
<p>We show this by arguing that this bound holds for every fixed $k$, when we take the probability over $x$, and so in particular it holds also for random $k$.
Indeed, for every fixed $k$, the map $x \mapsto E_k(x)$ is a one-to-one map, and so the distribution of $E_k(x)$ for random $x\in {0,1}^\ell$ is uniform over some set $T_k$ of size $2^{n+t}$.
For every $k$, the probability over $x$ that $E_k(x) \in S_0$ is equal to
$$\tfrac{|T_k \cap S_0|}{|T_k|} \leq \tfrac{|S_0|}{|T_k|} \leq \tfrac{2^n}{2^{n+t}}=2^{-t}$$
thus proving <a class="link" href="" >eqlongkeyprobproof</a>{.eqref}.</p>
<p>Now, for every $x$, define $p_x$ to be $\Pr_{k \leftarrow_R {0,1}^n}[ E_k(x) \in S_0]$. By <a class="link" href="" >eqlongkeyprobproof</a>{.eqref}, the expectation of $p_x$ over random $x \leftarrow_R {0,1}^n$ is at most $2^{-t}$ and so in particular by the averaging argument <em>there exists</em> some $x_1$ such that $p_{x_1} \leq 2^{-t}$.
Yet that means that the following adversary $Eve$ will be able to distinguish between an encryption of $x_0$ and an encryption of $x_1$ with probability at least $1-2^{-t-1}$:</p>
<ul>
<li>
<p><strong>Input:</strong> A ciphertext $y\in {0,1}^*$</p>
</li>
<li>
<p><strong>Operation:</strong> If $y\in S_0$, output $x_0$, otherwise output $x_1$.</p>
</li>
</ul>
<p>The probability that $Eve(E_k(x_0))=x_0$ is equal to $1$, while the probability that $Eve(E_k(x_1))=x_1$ is equal to $1-p_{x_1} \geq 1- 2^{-t}$. Hence the overall probability of $Eve$ guessing correctly is</p>
<p>$$
\tfrac{1}{2} \cdot 1 + \tfrac{1}{2} \cdot \left( 1-2^{-t} \right) = 1 - 2^{-t-1} ;.
$$
:::</p>
<h2 id="bibliographical-notes">Bibliographical notes
</h2><p>Much of this text is shared with <a class="link" href="https://introtcs.org"  target="_blank" rel="noopener"
    >my Introduction to Theoretical Computer Science textbook</a>.</p>
<p>Shannon&rsquo;s manuscript was written in 1945 but was classified, and a partial version was only published in 1949. Still it has revolutionized cryptography, and is the forerunner to much of what followed.</p>
<p>The Venona project&rsquo;s history is described in <a class="link" href="http://nsarchive.gwu.edu/NSAEBB/NSAEBB278/01.PDF"  target="_blank" rel="noopener"
    >this document</a>.
Aside from Grabeel and Zubko, credit to the discovery that the Soviets were reusing keys is shared by Lt. Richard Hallock, Carrie Berry, Frank Lewis, and Lt. Karl Elmquist, and there are others that have made important contributions to this project. See pages 27 and 28 in the document.</p>
<p>In a <a class="link" href="https://www.nsa.gov/news-features/declassified-documents/nash-letters/assets/files/nash_letters1.pdf"  target="_blank" rel="noopener"
    >1955 letter to the NSA</a> that only recently came forward, John Nash proposed an &ldquo;unbreakable&rdquo; encryption scheme.
He wrote <em>&ldquo;I hope my handwriting, etc. do not give the impression I am just a crank or circle-squarer&hellip; The significance of this conjecture [that certain encryption schemes are exponentially secure against key recovery attacks] .. is that it is quite feasible to design ciphers that are effectively unbreakable.&rdquo;</em>
John Nash made seminal contributions in mathematics and game theory, and was awarded both the Abel Prize in mathematics and the Nobel Memorial Prize in Economic Sciences.
However, he has struggled with mental illness throughout his life. His biography, <a class="link" href="https://en.wikipedia.org/wiki/A_Beautiful_Mind_%28book%29"  target="_blank" rel="noopener"
    >A Beautiful Mind</a> was made into a popular movie.
It is natural to compare Nash&rsquo;s 1955 letter to the NSA to the 1956 letter by <a class="link" href="https://www.cs.cmu.edu/~aada/courses/15251s15/www/notes/godel-letter.pdf"  target="_blank" rel="noopener"
    >Kurt G√∂del to John von Neumann</a>.
From the theoretical computer science point of view, the crucial difference is that while Nash informally talks about exponential vs polynomial computation time, he does not mention the word &ldquo;Turing Machine&rdquo; or other models of computation, and it is not clear if he is aware or not that his conjecture can be made mathematically precise (assuming a formalization of &ldquo;sufficiently complex types of enciphering&rdquo;).</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Referring to a book such as Katz-Lindell or Boneh-Shoup can be useful during this course to supplement these notes with additional discussions, extensions, details, practical applications, or references. In particular, in the current state of these lecture notes, almost all references and credits are omitted unless the name has become standard in the literature, or I believe that the story of some discovery can serve a pedagogical point. See the Katz-Lindell book for historical notes and references. This lecture shares a lot of text with (though is not identical to) my lecture on cryptography in the <a class="link" href="http://introtcs.org"  target="_blank" rel="noopener"
    >introduction to theoretical computer science</a> lecture notes.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Traditionally, <em>cryptography</em> was the name for the activity of <em>making</em> codes, while <em>cryptoanalysis</em> is the name for
the activity of <em>breaking</em> them, and <em>cryptology</em> is the name for the union of the two. These days <em>cryptography</em> is often used as the name for the
broad science of constructing and analyzing the security of not just encryptions but many schemes and protocols for protecting the confidentiality and integrity
of communication and computation.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Here is a nice exercise: compute (up to an order of magnitude) the probability that a 50-letter long message composed of random letters will end up not containing the letter &ldquo;L&rdquo;.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>There are about $10^{68}$ atoms in the galaxy, so even if we assumed that each one of those atoms was a computer that can process say $10^{21}$ decryption attempts per second (as the speed of light is $10^9$ meters per second and the diameter of an atom is about $10^{-12}$ meters), then it would still take $10^{113-89} = 10^{24}$ seconds, which is about $10^{17}$ years to exhaust all possibilities, while the sun is estimated to burn out in about 5 billion years.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 Example Person
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.26.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
