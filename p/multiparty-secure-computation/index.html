<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier Wikipedia defines cryptography as &ldquo;the practice and study of techniques for secure communication in the presence of third parties called adversaries&rdquo;. However, I think a better definition would be:\nCryptography is about replacing trust with mathematics.\nAfter all, the reason we work so hard in cryptography is because of a lack of trust. We wouldn&rsquo;t need encryption if Alice and Bob could be guaranteed that their communication, despite going through wireless and wired networks controlled and snooped upon by a plethora of entities, would be as reliable as if it has been hand delivered by a letter-carrier as reliable as Patti Whitcomb, as opposed to the nosy Eve who might look in the messages, or the malicious Mallory, who might tamper with them. We wouldn&rsquo;t need zero knowledge proofs if Vladimir could simply say &ldquo;trust me Barack, this is an authentic nuke&rdquo;. We wouldn&rsquo;t need electronic signatures if we could trust that all software updates are designed to make our devices safer and not, to pick a random example, to turn our phones into surveillance devices.\n">
<title>Multiparty secure computation</title>

<link rel='canonical' href='http://localhost:1313/p/multiparty-secure-computation/'>

<link rel="stylesheet" href="/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css"><meta property='og:title' content="Multiparty secure computation">
<meta property='og:description' content="Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier Wikipedia defines cryptography as &ldquo;the practice and study of techniques for secure communication in the presence of third parties called adversaries&rdquo;. However, I think a better definition would be:\nCryptography is about replacing trust with mathematics.\nAfter all, the reason we work so hard in cryptography is because of a lack of trust. We wouldn&rsquo;t need encryption if Alice and Bob could be guaranteed that their communication, despite going through wireless and wired networks controlled and snooped upon by a plethora of entities, would be as reliable as if it has been hand delivered by a letter-carrier as reliable as Patti Whitcomb, as opposed to the nosy Eve who might look in the messages, or the malicious Mallory, who might tamper with them. We wouldn&rsquo;t need zero knowledge proofs if Vladimir could simply say &ldquo;trust me Barack, this is an authentic nuke&rdquo;. We wouldn&rsquo;t need electronic signatures if we could trust that all software updates are designed to make our devices safer and not, to pick a random example, to turn our phones into surveillance devices.\n">
<meta property='og:url' content='http://localhost:1313/p/multiparty-secure-computation/'>
<meta property='og:site_name' content='Example Site'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' />
<meta name="twitter:title" content="Multiparty secure computation">
<meta name="twitter:description" content="Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier Wikipedia defines cryptography as &ldquo;the practice and study of techniques for secure communication in the presence of third parties called adversaries&rdquo;. However, I think a better definition would be:\nCryptography is about replacing trust with mathematics.\nAfter all, the reason we work so hard in cryptography is because of a lack of trust. We wouldn&rsquo;t need encryption if Alice and Bob could be guaranteed that their communication, despite going through wireless and wired networks controlled and snooped upon by a plethora of entities, would be as reliable as if it has been hand delivered by a letter-carrier as reliable as Patti Whitcomb, as opposed to the nosy Eve who might look in the messages, or the malicious Mallory, who might tamper with them. We wouldn&rsquo;t need zero knowledge proofs if Vladimir could simply say &ldquo;trust me Barack, this is an authentic nuke&rdquo;. We wouldn&rsquo;t need electronic signatures if we could trust that all software updates are designed to make our devices safer and not, to pick a random example, to turn our phones into surveillance devices.\n">
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true}, 
                {left: "$", right: "$", display: false}  
            ]
        });
    });
</script>
<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
    };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu13739649187745961479.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">üç•</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Example Site</a></h1>
            <h2 class="site-description">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="http://localhost:1313/" selected>English</option>
                                
                                    <option value="http://localhost:1313/zh-cn/" >‰∏≠Êñá</option>
                                
                                    <option value="http://localhost:1313/ar/" >ÿπÿ±ÿ®Ÿä</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#ideal-vs-real-model-security">Ideal vs. Real Model Security.</a></li>
    <li><a href="#formally-defining-secure-multiparty-computation">Formally defining secure multiparty computation</a>
      <ol>
        <li><a href="#first-attempt-a-slightly-too-ideal-definition">First attempt: a slightly &ldquo;too ideal&rdquo; definition</a></li>
        <li><a href="#allowing-for-aborts">Allowing for aborts</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li>
      <ol>
        <li><a href="#some-comments">Some comments:</a></li>
      </ol>
    </li>
    <li><a href="#example-second-price-auction-using-bitcoin">Example: Second price auction using bitcoin</a>
      <ol>
        <li><a href="#another-example-distributed-and-threshold-cryptography">Another example: distributed and threshold cryptography</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#proving-the-fundamental-theorem">Proving the fundamental theorem:</a></li>
    <li><a href="#hbctomalred">Malicious to honest but curious reduction</a>
      <ol>
        <li><a href="#hbctomalthm"></a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li>
      <ol>
        <li><a href="#handling-probabilistic-strategies">Handling probabilistic strategies:</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/multiparty-secure-computation/">Multiparty secure computation</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    30 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="sfeonechap">Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier
</h1><p>Wikipedia <a class="link" href="https://en.wikipedia.org/wiki/Cryptography"  target="_blank" rel="noopener"
    >defines</a> cryptography as &ldquo;the practice and study of techniques for secure communication in the presence of third parties called adversaries&rdquo;.
However, I think a better definition would be:</p>
<blockquote>
<p><em>Cryptography is about replacing trust with mathematics.</em></p>
</blockquote>
<p>After all, the reason we work so hard in cryptography is because of a lack of trust.
We wouldn&rsquo;t need encryption if Alice and Bob could be guaranteed that their communication, despite going through wireless and wired networks controlled and snooped upon by a plethora of entities, would be as reliable as if it has been hand delivered by a letter-carrier as reliable as <a class="link" href="http://old.iolaregister.com/Local%20News/Stories/Weatherwontstopcarriers.html"  target="_blank" rel="noopener"
    >Patti Whitcomb</a>, as opposed to the nosy Eve who might look in the messages, or the malicious Mallory, who might tamper with them.
We wouldn&rsquo;t need zero knowledge proofs if Vladimir could simply say &ldquo;trust me Barack, this is an authentic nuke&rdquo;.
We wouldn&rsquo;t need electronic signatures if we could trust that all software updates are designed to make our devices safer and not, to pick a random example, to turn our phones into surveillance devices.</p>
<p>Unfortunately, the world we live in is not as ideal, and we need these cryptographic tools.
But what is the limit of what we can achieve?
Are these examples of encryption, authentication, zero knowledge etc. isolated cases of good fortune, or are they special cases of a more general theory of what is possible in cryptography?
It turns out that the latter is the case and there is in fact an extremely general formulation that (in some sense) captures all of the above and much more.
This notion is called <em>multiparty secure computation</em> or sometimes <em>secure function evaluation</em> and is the topic of this lecture.
We will show (a relaxed version of) what I like to call &ldquo;the fundamental theorem of cryptography,&rdquo; namely that under natural computational conjectures (in particular the LWE conjecture, as well as the RSA or Factoring assumptions) essentially every cryptographic task can be achieved.
This theorem emerged from the 1980&rsquo;s works of Yao, Goldreich-Micali-Wigderson, and many others.
As we&rsquo;ll see, like the &ldquo;fundamental theorems&rdquo; of other fields, this is not a result that closes off the field but rather opens up many other questions.
But before we can even state the result, we need to talk about how can we even define security in a general setting.</p>
<h2 id="ideal-vs-real-model-security">Ideal vs. Real Model Security.
</h2><p>The key notion is that cryptography aims to replace <em>trust</em>.
Therefore, we imagine an <em>ideal world</em> where there is some universally trusted party (which cryptographer Silvio Micali likes to denote by Jimmy Carter, but feel free to swap in your own favorite trustworthy personality) that communicates with all participants of the protocol or interaction, including potentially the adversary.
We define security by stating that whatever the adversary can achieve in our real world, could have also been achieved in the ideal world.</p>
<p>For example, for obtaining secure communication, Alice will send her message to the trusted party, who will then convey it to Bob.
The adversary learns nothing about the message&rsquo;s contents, nor can she change them.
In the zero knowledge application, to prove that there exists some secret $x$ such that $f(x)=1$ where $f(\cdot)$ is a public function,   the prover Alice sends to the trusted party her secret input $x$, the trusted party then verifies that $f(x)=1$ and simply sends to Bob the message &ldquo;the statement is true&rdquo;.
It does not reveal to Bob anything about the secret $x$ beyond that.</p>
<p>But the paradigm goes well beyond this.
For example, <a class="link" href="https://en.wikipedia.org/wiki/Vickrey_auction"  target="_blank" rel="noopener"
    >second price (or Vickrey) auctions</a> are known as a way to incentivize bidders to bid their true value.
In these auctions, every potential buyer sends a sealed bid, and the item goes to the highest bidder, who only needs to pay the price of the second-highest bid.
We could imagine a digital version, where buyers send encrypted versions of their bids.
The auctioneer could announce who the winner is and what was the second largest bid, but could we really trust him to do so faithfully?
Perhaps we would want an auction where even the auctioneer doesn&rsquo;t learn anything about the bids beyond the identity of the winner and the value of the second highest bid?
Wouldn&rsquo;t it be great if there was a trusted party that all bidders could share with their private values, and it would announce the results of the auction but nothing more than that?
This could be useful not just in second price auctions but to implement many other mechanisms, especially if you are a <a class="link" href="https://www.cs.purdue.edu/homes/aliaga/cs197-10/papers/bogetoft.pdf"  target="_blank" rel="noopener"
    >Danish sugar beet farmer</a>.</p>
<p>There are other examples as well. Perhaps two hospitals might want to figure out if the same patient visited both, but do not want (or are legally not allowed) to share with one another the list of people that visited each one.
A trusted party could get both lists and output only their intersection.</p>
<p>The list goes on and on. Maybe we want to aggregate securely information of the performance of <a class="link" href="https://eprint.iacr.org/2011/662.pdf"  target="_blank" rel="noopener"
    >Estonian IT firms</a> or the financial health of <a class="link" href="http://arxiv.org/abs/1111.5228"  target="_blank" rel="noopener"
    >wall street banks</a>. Almost every cryptographic task could become trivial if we just had access to a universally trusted party.
But of course in the real world, we don&rsquo;t.
This is what makes the notion of <em>secure multiparty computation</em> so exciting.</p>
<h2 id="formally-defining-secure-multiparty-computation">Formally defining secure multiparty computation
</h2><p>We now turn to formal definitions. As we discuss below, there are many variants of secure multiparty computation, and we pick one simple version below.
A <em>$k$-party protocol</em> is a set of efficiently computable $k$ prescribed interactive strategies for all $k$ parties.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>
We assume the existence of an authenticated and private point to point channel between every pair of parties (this can be implemented using signatures and encryptions).<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>
A <em>$k$-party functionality</em>  is a probabilistic process $F$ mapping $k$ inputs in ${0,1}^n$ into $k$ outputs in ${0,1}^n$.<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
<h3 id="first-attempt-a-slightly-too-ideal-definition">First attempt: a slightly &ldquo;too ideal&rdquo; definition
</h3><p>Here is one attempt of a definition that is clean but a bit too strong. Nevertheless it captures much of the spirit of secure multiparty computation:</p>
<p>::: {.definition title=&ldquo;MPC without aborts&rdquo; #mpcnoaborts}
Let $F$ be a $k$-party functionality.  A <em>secure protocol for $F$</em> is a protocol for $k$ parties satisfying that for every $T\subseteq [k]$ and every efficient adversary $A$,  there exists an efficient &ldquo;ideal adversary&rdquo; (i.e., efficient interactive algorithm)  $S$ such that for every set of inputs ${ x_i }_{i\in [k]\setminus T}$ the following two distributions are computationally indistinguishable:</p>
<ul>
<li>
<p>The tuple $(y_1,\ldots,y_k)$ of outputs of all the parties (both controlled and not controlled by the adversary) in an execution of the protocol where $A$ controls the parties in $T$ and the inputs of the parties not in $T$ are given by ${ x_i }_{i\in [k]\setminus T}$.</p>
</li>
<li>
<p>The tuple $(y_1,\ldots,y_k)$ that is computed using the following process:</p>
<p>a. We let ${ x_i }_{i \in T}$ be chosen by $S$, and compute $(y&rsquo;_1,\ldots,y&rsquo;_k)=F(x_1,\ldots,x_k)$.</p>
<p>b. For every $i\in [k]$, if $i\not\in T$ (i.e., party $i$ is &ldquo;honest&rdquo;) then $y_i=y&rsquo;_i$ and otherwise, we let $S$ choose $y_i$.
:::</p>
</li>
</ul>
<p>That is, the protocol is secure if whatever an adversary can gain by taking complete control over the set of parties in $T$, could have been gained by simply using this control to choose particular inputs ${ x_i }_{i\in T}$, run the protocol honestly, and observe the outputs of the functionality.<br>
Note that in particular if $T=\emptyset$ (and hence there is no adversary) then if the parties&rsquo; inputs are $(x_1,\ldots,x_k)$ then their outputs will equal $F(x_1,\ldots,x_k)$.</p>
<h3 id="allowing-for-aborts">Allowing for aborts
</h3><p><a class="link" href="" >mpcnoaborts</a>{.ref} above is a little too strong, in the following sense.
Consider the case that $k=2$ where there are two parties Alice (Party $1$) and Bob (Party $2$) that wish to compute some output $F(x_1,x_2)$.
If Bob is controlled by the adversary then he clearly can simply abort the protocol and prevent Alice from computing $y_1$.
Thus, in this case in the actual execution of the protocol the output $y_1$ will be some error message (which we denote by $\bot$).
But we did not allow this possiblity for the idealized adversary $S$: if $1\not\in T$ then it must be the case that the output $y_1$ is equal to $y&rsquo;_1$ for some $(y&rsquo;_1,y&rsquo;_2)=F(x_1,x_2)$.<br>
This means that we would be able to distinguish between the output in the real and ideal setting.<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>
This motivates the following, slightly more messy definition, that allows for the ability of the adversary to abort the execution at any point in time:</p>
<p>::: {.definition title=&ldquo;MPC with aborts&rdquo; #MPCdef}
Let $F$ be a $k$-party functionality.  A <em>secure protocol for $F$</em> is a protocol for $k$ parties satisfying that for every $T\subseteq [k]$ and every efficient adversary $A$,  there exists an efficient &ldquo;ideal adversary&rdquo; (i.e., efficient interactive algorithm)  $S$ such that for every set of inputs ${ x_i }_{i\in [k]\setminus T}$ the following two distributions are computationally indistinguishable:</p>
<ul>
<li>
<p>The tuple $(y_1,\ldots,y_k)$ of outputs of all the parties (both controlled and not controlled by the adversary) in an execution of the protocol where $A$ controls the parties in $T$ and the inputs of the parties not in $T$ are given by ${ x_i }_{i\in [k]\setminus T}$ we denote by $y_i = \top$ if the $i^{th}$ party aborted the protocol.</p>
</li>
<li>
<p>The tuple $(y_1,\ldots,y_k)$ that is computed using the following process:</p>
<p>a. We let ${ x_i }_{i \in T}$ be chosen by $S$, and compute $(y&rsquo;_1,\ldots,y&rsquo;_k)=F(x_1,\ldots,x_k)$.</p>
<p>b. For $i=1,\ldots,k$ do the following: ask $S$ if it wishes to abort at this stage, and if it doesn&rsquo;t then the $i^{th}$ party learns $y&rsquo;_i$. If the adversary did abort then we exit the loop at this stage and the parties $i+1,\ldots,k$ (regardless if they are honest or malicious) do not learn the corresponding outputs.</p>
<p>c. Let $k&rsquo;$ be the last non-abort stage we reached above. For every $i\not\in T$, if $i \leq k&rsquo;$ then $y_i =y&rsquo;_i$ and if $i&gt;k&rsquo;$ then $y&rsquo;<em>i=\bot$. We let the adversary $S$  choose ${ y_i }</em>{i\in T}$.
:::</p>
</li>
</ul>
<p><img src="/figure/real-ideal.jpg"
	
	
	
	loading="lazy"
	
		alt="We define security of a protocol implementing a functionality $F$ by stipulating that for every adversary $A$ that controls a subset of the parties, $A$&rsquo;s view in an actual execution of the protocol would be indistinguishable from its view in an ideal setting where all the parties send their inputs to an idealized and perfectly trusted party, who then computes the outputs and sends it to each party."
	
	
>{#tmplabelfig}</p>
<p>Here are some good exercises to make sure you follow the definition:</p>
<ul>
<li>
<p>Let $F$ be the two party functionality such that $F(H|C,H&rsquo;)$ outputs $(1,1)$ if the graph $H$ equals the graph $H&rsquo;$ and $C$ is a Hamiltonian cycle and otherwise outputs $(0,0)$. Prove that a protocol for computing $F$ is a zero knowledge proof<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup> system for the language of Hamiltonicity.<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></p>
</li>
<li>
<p>Let $F$ be the $k$-party functionality that on inputs $x_1,\ldots,x_k \in {0,1}$ outputs to all parties the majority value of the $x_i$&rsquo;s.  Then, in any protocol that securely computes $F$,  for any adversary that controls less than half of the parties, if at least $n/2+1$ of the other parties&rsquo; inputs equal $0$, then the adversary will not be able to cause an honest party to output $1$.</p>
</li>
</ul>
<blockquote>
<h1 id="heading">
</h1></blockquote>
<p>It is an excellent idea for you to pause here and try to work out at least informally these exercises.</p>
<p>Amazingly, we can obtain such a protocol for <em>every</em> functionality:</p>
<blockquote>
<h1 id="MPCthm">
</h1></blockquote>
<p>Under reasonable assumptions<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup> for every polynomial-time computable $k$-functionality $F$ there is a polynomial-time protocol that computes it securely.</p>
<p><a class="link" href="" >MPCthm</a>{.ref} was originally proven by Yao in 1982 for the special case of two party functionalities, and then proved for the general case by Goldreich, Micali,  and Wigderson in 1987.
As discussed below, many variants of this theorem have been shown, and this line of research is still ongoing.</p>
<h3 id="some-comments">Some comments:
</h3><p>There is in fact not a single theorem but rather many variants of this fundamental theorem obtained by great many people, depending on the different security properties desired, as well as the different cryptographic and setup assumptions. Some of the issues studied in the literature include the following:</p>
<ul>
<li>
<p><strong>Fairness, guaranteed output delivery:</strong> The definition above does not attempt to protect against &ldquo;denial of service&rdquo; attacks, in the sense that the adversary is allowed, even in the ideal case, to prevent the honest parties from receiving their outputs.<br>
As mentioned above, without honest majority this is essential for similar reasons to the issue we discussed in <a class="link" href="http://www.boazbarak.org/cs127/chap07_hash_functions.pdf"  target="_blank" rel="noopener"
    >our lecture on bitcoin</a>  why achieving consensus is hard if there isn&rsquo;t a honest majority.
When there is an honest majority, we can achieve the property of <em>guaranteed output delivery</em>, which offers protection against such &ldquo;denial of service&rdquo; attacks.
Even when there is no guaranteed output delivery, we might want the property of <em>fairness</em>, whereby we guarantee that if the honest parties don&rsquo;t get the output then neither does the adversary.
There has been extensive study of fairness and there are protocols achieving variants on it under various computational and setup assumptions.</p>
</li>
<li>
<p><strong>Network models:</strong>  The current definition assumes we have a set of $k$ parties with known identities with pairwise secure (confidential and authenticated) channels between them. Other network models studies include broadcast channel, non-private networks, and even <a class="link" href="https://eprint.iacr.org/2007/464"  target="_blank" rel="noopener"
    >no authentication</a>).</p>
</li>
<li>
<p><strong>Setup assumptions:</strong> The definition does not assume a trusted third party, but people have studied different setup assumptions including a public key infrastructure, common reference string, and more.</p>
</li>
<li>
<p><strong>Adversarial power:</strong> It turns out that under certain conditions, it can be possible to obtain secure multiparty computation with respect to adversaries that have unbounded computational power (so called &ldquo;information theoretic security&rdquo;). People have also studies different variants of adversaries including &ldquo;honest but curious&rdquo; or &ldquo;passive adversaries&rdquo;, as well as &ldquo;covert&rdquo; adversaries that only deviate from the protocol if they won&rsquo;t be caught. Other settings studied limit the adversary&rsquo;s ability to control parties (e.g., honest majority, smaller fraction of parties or particular patterns of control, adaptive vs static corruption).</p>
</li>
<li>
<p><strong>Concurrent compositions:</strong>  The definition displayed above are for <em>standalone execution</em> which is known not to automatically imply security with respect to <em>concurrent composition</em>, where many copies of the same protocol (or different protocols) could be executed simultaneously. This opens up all sorts of new attacks.<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup>  See <a class="link" href="http://u.cs.biu.ac.il/~lindell/thesis.html"  target="_blank" rel="noopener"
    >Yehuda Lindell&rsquo;s thesis</a> (or <a class="link" href="http://u.cs.biu.ac.il/~lindell/LNCSmonograph.html"  target="_blank" rel="noopener"
    >this updated version</a>) for more. A very general notion known as &ldquo;UC security&rdquo; (which stands for &ldquo;Universally Composable&rdquo; or maybe &ldquo;Ultimate Chuck&rdquo;) has been proposed to achieve security in these settings, though at a price of additional setup assumptions, see <a class="link" href="http://www.cs.tau.ac.il/~canetti/materials/ICALP08.pdf"  target="_blank" rel="noopener"
    >here</a> and <a class="link" href="http://eprint.iacr.org/2007/475"  target="_blank" rel="noopener"
    >here</a>.</p>
</li>
<li>
<p><strong>Communication:</strong> The communication cost for <a class="link" href="" >MPCthm</a>{.ref} can be proportional to the size of the circuit that computes $F$. This can be a very steep cost, especially when computing over large amounts of data. It turns out that we can sometimes avoid this cost using fully homomorphic encryption or other techniques.</p>
</li>
<li>
<p><strong>Efficiency vs. generality:</strong> While <a class="link" href="" >MPCthm</a>{.ref}  tells us that essentially every protocol problem can be solved <em>in principle</em>, its proof will almost never yield a protocol you actually want to run since it has enormous efficiency overhead. The issue of efficiency is the biggest reason why secure multiparty computation has so far not had a great many practical applications. However, researchers have been showing more efficient tailor-made protocols for particular problems of interest, and there has been steady progress in making those results more practical. See <a class="link" href="http://crypto.biu.ac.il/5th-biu-winter-school"  target="_blank" rel="noopener"
    >the slides and videos from this workshop</a> for more.</p>
</li>
</ul>
<p><strong>Is multiparty secure computation the end of crypto?</strong> The notion of secure multiparty computation seems so strong that you might think that once it is achieved, aside from efficiency issues, there is nothing else to be done in cryptography. This is very far from the truth. Multiparty secure computation does give a way to solve a great many problems in the setting where we have arbitrary rounds of interactions and unbounded communication, but this is far from being always the case. As we mentioned before, interaction can sometimes make a <em>qualitative</em> difference (when Alice and Bob are separated by time rather than space). As we&rsquo;ve seen in the discussion of fully homomorphic encryption, there are also other properties, such as compact communication, which are not implied by multiparty secure computation but can make all the difference in contexts such as cloud computing. That said, multiparty secure computation is an extremely general paradigm that does apply to many cryptographic problems.</p>
<p><strong>Further reading:</strong> The <a class="link" href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=1004&amp;context=jpc"  target="_blank" rel="noopener"
    >survey of Lindell and Pinkas</a> gives a good overview of the different variants and security properties considered in the literature, see also Section 7 in <a class="link" href="http://www.wisdom.weizmann.ac.il/~oded/foc-sur04.html"  target="_blank" rel="noopener"
    >this survey of Goldreich</a>. Chapter 6 in <a class="link" href="http://www.cs.cornell.edu/courses/cs4830/2010fa/lecnotes.pdf"  target="_blank" rel="noopener"
    >Pass and Shelat&rsquo;s notes</a> is also a good source.</p>
<h2 id="example-second-price-auction-using-bitcoin">Example: Second price auction using bitcoin
</h2><p>Suppose we have the following setup: an auctioneer wants to sell some item and run a second-price auction, where each party submits a sealed bid, and the highest bidder gets the item for the price of the second highest bid.
However, as mentioned above, the bidders do not want the auctioneer to learn what their bid was, and in general nothing else other than the identity of the highest bidder and the value of the second highest bid.
Moreover, we might want the payment to be via an electronic currency such as bitcoin, so the auctioneer not only gets the information about the winning bid but an actual self-certifying transaction they can use to get the payment.</p>
<p>Here is how we could obtain such a protocol using secure multiparty computation:</p>
<ul>
<li>
<p>We have $k$ parties where the first party is the auctioneer and parties $2,\ldots,k$ are bidders. Let&rsquo;s assume for simplicity that each party $i$ has a public key $v_i$ that is associated with some bitcoin account.<sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup> We treat all these keys as the public input.</p>
</li>
<li>
<p>The private input of bidder $i$ is the value $x_i$ that it wants to bid as well as the secret key $s_i$ that corresponds to their public key.</p>
</li>
<li>
<p>The functionality only provides an output to the auctioneer, which would be the identity $i$ of the winning bidder as well as a valid signature on this bidder transferring $x$ bitcoins to the key $v_1$ of the auctioneer, where $x$ is the value of the second largest valid bid (i.e., $x$ equals to the second largest $x_j$ such that $s_j$ is indeed the private key corresponding to $v_j$.)</p>
</li>
</ul>
<p>It&rsquo;s worthwhile to think about what a secure protocol for this functionality accomplishes. For example:</p>
<ul>
<li>
<p>The fact that in the ideal model the adversary needs to choose its queries independently means that the adversary cannot get any information about the honest parties&rsquo; bids before deciding on its bid.</p>
</li>
<li>
<p>Despite all parties using their signing keys as inputs to the protocol, we are guaranteed that no one will learn anything about another party&rsquo;s signing key except the single signature that will be produced.</p>
</li>
<li>
<p>Note that if $i$ is the highest bidder and $j$ is the second highest, then at the end of the protocol we get a valid signature using $s_i$ on a transaction transferring $x_j$ bitcoins to $v_1$, despite $i$ not knowing the value $x_j$ (and in fact never learning the identity of $j$.) Nonetheless, $i$ is guaranteed that the signature produced will be on an amount not larger than its own bid and an amount that one of the other bidders actually bid for.</p>
</li>
</ul>
<p>I find the ability to obtain such strong notions of security pretty remarkable.
This demonstrates the tremendous power of obtaining protocols for general functionalities.</p>
<h3 id="another-example-distributed-and-threshold-cryptography">Another example: distributed and threshold cryptography
</h3><p>It sometimes makes sense to use multiparty secure computation for <em>cryptographic computations</em> as well.
For example, there might be several reasons why we would want to &ldquo;split&rdquo; a secret key between several parties, so no party knows it completely.</p>
<ul>
<li>
<p>Some proposals for <em>key escrow</em> (giving government or other entity an option for decrypting communication) suggested splitting a cryptographic key between several agencies or institutions (say the FBI, the courts, etc.) so that they must collaborate in order to decrypt communication, thus hopefully preventing unlawful access.</p>
</li>
<li>
<p>On the other side, a company might wish to split its own key between several servers residing in different countries, to ensure not one of them is completely under one jurisdiction. Or it might do such splitting for technical reasons, so that if there is a break in at a single site, the key is not compromised.</p>
</li>
</ul>
<p>There are several other such examples.
One problem with this approach is that splitting a cryptographic key is not the same as cutting a 100 dollar bill in half.
If you simply give half of the bits to each party, you could significantly harm security. (For example, it is possible to recover the full RSA key <a class="link" href="http://eprint.iacr.org/2008/510.pdf"  target="_blank" rel="noopener"
    >from only $27%$ of its bits</a>).</p>
<p>Here is a better approach, known as <a class="link" href="https://en.wikipedia.org/wiki/Secret_sharing"  target="_blank" rel="noopener"
    >secret sharing</a>:
To securely share a string $s\in{0,1}^n$ among $k$ parties so that any $k-1$ of them have no information about it, we choose $s_1,\ldots,s_{k-1}$ at random in ${0,1}^n$ and let $s_k = s \oplus s_1 \oplus \cdots s_{k-1}$ ($\oplus$ as usual denotes the XOR operation), and give party $i$ the string $s_i$, which is known as the <em>$i^{th}$ share</em> of $s$.
Note that $s = s_1 \oplus \cdots \oplus s_k$ and so given all $k$ pieces we can reconstruct the key.
Clearly the first $k-1$ parties did not receive any information about $s$ (since their shares were generated independent of $s$), but the following not-too-hard claim
shows that this holds for <em>every</em> set of $k-1$ parties:</p>
<blockquote>
<h1 id="secretsharinglem">
</h1></blockquote>
<p>For every $s\in{0,1}^n$, and set $T\subseteq [k]$ of size $k-1$, we get exactly the same distribution over $(s_1,\ldots,s_k)$ as above if
we choose $s_i$ for $i\in T$ at random and set $s_t = s \oplus_{i\in T} s_i$ where $t = [k]\setminus T$.</p>
<p>We leave the proof of <a class="link" href="" >secretsharinglem</a>{.ref} as an exercise.</p>
<p>Secret sharing solves the problem of protecting the key &ldquo;at rest&rdquo; but if we actually want to <em>use</em> the secret key in order to sign or decrypt some message, then it seems we need to collect all the pieces together into one place, which is exactly what we wanted to avoid doing.
This is where multiparty secure computation comes into play; we can define a functionality $F$ taking public input $m$ and secret inputs $s_1,\ldots,s_k$ and producing a signature or decryption of $m$.
In fact, we can go beyond that and even have the parties sign or decrypt a message without them knowing what this message is, except that it satisfies some conditions.</p>
<p>Moreover, secret sharing can be generalized so that a threshold other than $k$ is necessary and sufficient to reconstruct the secret (and people have also studied more complicated access patterns). Similarly multiparty secure computation can be used to achieve distributed cryptography with finer access control mechanisms.</p>
<h2 id="proving-the-fundamental-theorem">Proving the fundamental theorem:
</h2><p>We will complete the proof of (a relaxed version of) the fundamental theorem over this lecture and the next one.
The proof consists of two phases:</p>
<ol>
<li>
<p>A protocol for the &ldquo;honest but curious&rdquo; case using fully homomorphic encryption.</p>
</li>
<li>
<p>A reduction of the general case into the &ldquo;honest but curious&rdquo; case where the adversary follows the protocol precisely but merely attempts to learn some information on top of the output that it is &ldquo;entitled to&rdquo; learn. (This reduction is based on zero knowledge proofs and is due to Goldreich, Micali and Wigderson)</p>
</li>
</ol>
<p>We note that while fully homomorphic encryption yields a conceptually simple approach for the first step, it is not currently the most efficient approach, and rather most practical implementations are based on the technique known as &ldquo;Yao&rsquo;s Garbled Ciruits&rdquo; (see <a class="link" href="http://u.cs.biu.ac.il/~lindell/efficient-protocols.html"  target="_blank" rel="noopener"
    >this book</a> or <a class="link" href="https://eprint.iacr.org/2004/175.pdf"  target="_blank" rel="noopener"
    >this paper</a> or <a class="link" href="https://www.cs.uic.edu/pub/Bits/PeterSnyder/Peter_Snyder_-_Garbled_Circuits_WCP_2_column.pdf"  target="_blank" rel="noopener"
    >this survey</a> ) which in turn is based a notion known as <a class="link" href="https://en.wikipedia.org/wiki/Oblivious_transfer"  target="_blank" rel="noopener"
    >oblivious transfer</a> which can be thought of as a &ldquo;baby private information retrieval&rdquo; (though it preceded the latter notion).</p>
<p>We will focus on the case of <em>two parties</em>. The same ideas extend to $k&gt;2$ parties but with some additional complications.</p>
<h2 id="hbctomalred">Malicious to honest but curious reduction
</h2><p>We start from the second stage. Giving a reduction transforming a protocol in the &ldquo;honest but curious&rdquo; setting into a protocol secure in the malicious setting. That is, we will prove the following theorem:</p>
<blockquote>
<h3 id="hbctomalthm">
</h3></blockquote>
<p>There is a polynomial-time &ldquo;compiler&rdquo; $C$ such that for every for every $k$ party protocol $(P_1,\ldots,P_k)$ (where all $P_i$&rsquo;s are polynomial-time computable potentially randomized strategies), $(\tilde{P}_1,\ldots,\tilde{P}_k) = C(P_1,\ldots,P_k)$ is a $k$-tuple polynomial-time computable strategies and moreover if $(P_1,\ldots,P_k)$ was a protocol for computing some (potentially randomized) functionality $F$ secure with respect to honest-but-curious adversaries, then $(\tilde{P}_1,\ldots,\tilde{P}_k)$ is a protocol for computing the same $F$ secure with respect to <em>malicious</em> adversaries.</p>
<p>The remainder of this section is devoted to the proof of <a class="link" href="" >hbctomalthm</a>{.ref}.
For ease of notation we will focus on the $k=2$ case, where there are only two parties (&ldquo;Alice&rdquo; and &ldquo;Bob&rdquo;) although these techniques generalize to arbitrary number of parties $k$.
Note that a priori, it is not obvious at all that such a compiler should exist.
In the &ldquo;honest but curious&rdquo; setting we assume the adversary follows the protocol to the letter.
Thus a protocol where Alice gives away all her secrets to Bob if he merely <a class="link" href="https://xkcd.com/424/"  target="_blank" rel="noopener"
    >asks her to do so politely</a> can be secure in the &ldquo;honest but curious&rdquo; setting if Bob&rsquo;s instructions are not to ask.
More seriously, it could very well be that Bob has an ability to deviate from the protocol in subtle ways that would be completely undetectable but allow him to learn Alice&rsquo;s secrets.
Any transformation of the protocol to obtain security in the malicious setting will need to rule out such deviations.</p>
<p>The main idea is the following: we do the compilation one party at a time - we first transform the protocol so that it will remain secure even if Alice tries to cheat, and then transform it so it will remain secure even if Bob tries to cheat.
Let&rsquo;s focus on Alice.
Let&rsquo;s imagine (without loss of generality) that Alice and Bob alternate sending messages in the protocol with Alice going first, and so Alice sends the odd messages and Bob sends the even ones.
Lets denote by $m_i$ the message sent in the $i^{th}$ round of the protocol.
Alice&rsquo;s instructions can be thought of as a sequence of functions $f_1,f_3,\cdots,f_t$ (where $t$ is the last round in which Alice speaks) where each $f_i$ is an efficiently computable function mapping Alice&rsquo;s secret input $x_1$, (possibly) her random coins $r_1$, and the transcript of the previous messages $m_1,\ldots,m_{i-1}$ to the next message $m_i$.
The functions ${ f_i }$ are publicly known and part of the protocol&rsquo;s instructions. The only thing that Bob doesn&rsquo;t know is $x_1$ and $r_1$.
So, our idea would be to change the protocol so that after Alice sends the message $i$, she <em>proves</em> to Bob that it was indeed computed correctly using $f_i$.
If $x_1$ and $r_1$ weren&rsquo;t secret, Alice could simply send those to Bob so he can verify the computation on his own.
But because they are (and the security of the protocol could depend on that) we instead use a <em>zero knowledge proof</em>.</p>
<p>Let&rsquo;s assume for starters that Alice&rsquo;s strategy is <em>deterministic</em> (and so there is no random tape $r_1$).
A first attempt to ensure she can&rsquo;t use a malicious strategy would be for Alice to follow the message $m_i$ with a zero knowledge proof that there exists some $x_1$ such that $m_i=f_i(x_1,m_1,\ldots,m_{i-1})$.
However, this will actually not be secure - it is worth while at this point for you to pause and think if you can understand the problem with this solution.</p>
<blockquote>
<h1 id="heading-1">
</h1></blockquote>
<p>Really, please stop and think why this will not be secure.</p>
<p>\newpage</p>
<blockquote>
<h1 id="heading-2">
</h1></blockquote>
<p>Did you stop and think?</p>
<p>The problem is that at every step Alice proves that there exists <em>some</em> input $x_1$ that can explain her message but she doesn&rsquo;t prove that it&rsquo;s <em>the same input for all messages</em>.
If Alice was being truly honest, she should have picked her input once and use it throughout the protocol, and she could not compute the first message according to the input $x_1$ and then the third message according to some input $x&rsquo;_1 \neq x_1$.
Of course we can&rsquo;t have Alice reveal the input, as this would violate security.
The solution is for Alice to <em>commit</em> in advance to the input.
We have seen commitments before, but let us now formally define the notion:</p>
<blockquote>
<h1 id="commitmentdef">
</h1></blockquote>
<p>A <em>commitment scheme</em> for strings of length $\ell$ is a two party protocol between the <em>sender</em> and <em>receiver</em> satisfying the following:</p>
<blockquote>
</blockquote>
<ul>
<li><strong>Hiding (sender&rsquo;s security):</strong> For every two sender inputs $x,x&rsquo; \in {0,1}^\ell$, and no matter what efficient strategy the receiver uses, it cannot distinguish between the interaction with the sender when the latter uses $x$ as opposed to when it uses $x&rsquo;$.</li>
</ul>
<blockquote>
</blockquote>
<ul>
<li><strong>Binding (reciever&rsquo;s security):</strong> No matter what (efficient or non efficient) strategy the sender uses, if the reciever follows the protocol then with probability $1-negl(n)$, there will exist at most a single string $x\in{0,1}^\ell$ such that the transcript is consistent with the input $x$ and some sender randomness $r$.</li>
</ul>
<p>That is, a commitment is the digital analog to placing a message in a sealed envelope to be opened at a later time. To commit to a message $x$ the sender and reciever interact according to the protocol, and to <em>open</em> the commitment the sender simply sends $x$ as well as the random coins it used during the commitment phase.
The variant we defined above is known as <em>computationally hiding and statistically binding</em>, since the sender&rsquo;s security is only guaranteed against efficient receivers while the binding property is guaranteed against all senders.
There are also statistically hiding and computationally binding commitments, though it can be shown that we need to restrict to efficient strategies for at least one of the parties.</p>
<p>We have already seen a commitment scheme before (due to Naor): the receiver sends a random $z\leftarrow_R{0,1}^{3n}$ and the sender commits to a bit $b$ by choosing a random $s\in{0,1}^n$ and sending $y = PRG(s)\oplus bz$ where $PRG:{0,1}^n\rightarrow{0,1}^{3n}$ is a pseudorandom generator.
It&rsquo;s a good exercise to verify that it satisfies the above definitions.
By running this protocol $\ell$ times in parallel we can commit to a string of any polynomial length.</p>
<p>We can now describe the transformation ensuring the protocol is secure against a malicious Alice in full, for the case that that the original strategy of Alice is <em>deterministic</em> (and hence uses no random coins)</p>
<ul>
<li>
<p>Initially Alice and Bob engage in a commitment scheme where Alice commits to her input $x_1$. Let $\tau$ be the transcript of this commitment phase and $r_{com}$ be the randomness Alice used during it.<sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup></p>
</li>
<li>
<p>For $i=1,2,\ldots$:</p>
<ul>
<li>
<p>If $i$ is even then Bob sends $m_i$ to Alice</p>
</li>
<li>
<p>If $i$ is odd then Alice sends $m_i$ to Bob and then they engage in a zero knowledge proof that there exists $x_1,r_{com}$ such that (1) $x_1,r_{com}$ is consistent with $\tau$, and (2) $m_i = f_i(x_1,m_1,\ldots,m_{i-1})$. The proof is repeated a sufficient number of times to ensure that if the statement is false then Bob rejects with $1-negl(n)$ probability.</p>
</li>
<li>
<p>If the proof is rejected then Bob aborts the protocol.</p>
</li>
</ul>
</li>
</ul>
<p>We will not prove security but will only sketch it here, see <a class="link" href="http://www.nowpublishers.com/article/Details/TCS-001"  target="_blank" rel="noopener"
    >Section 7.3.2 in Goldreich&rsquo;s survey</a> for a more detailed proof:</p>
<ul>
<li>
<p>To argue that we maintain security for <em>Alice</em> we use the zero knowledge property: we claim that Bob could not learn anything from the zero knowledge proofs precisely because he could have simulated them by himself. We also use the hiding property of the commitment scheme. To prove security formally we \ need to show that whatever Bob learns in the modified protocol, he could have learned in the original protocol as well. We do this by <em>simulating</em> Bob by replacing the commitment scheme with commitment to some random junk instead of $x_1$ and the zero knowledge proofs with their simulated version. The proof of security requires a hybrid argument, and is again a good exercise to try to do it on your own.</p>
</li>
<li>
<p>To argue that we maintain security for <em>Bob</em> we use the binding property of the commitment scheme as well as the soundness property of the zero knowledge system. Once again for the formal proof we need to show that we could transform any potentially malicious strategy for Alice in the modified protocol into an &ldquo;honest but curious&rdquo; strategy in the original protocol (also allowing Alice the ability to abort the protocol). It turns out that to do so, it is not enough that the zero knowledge system is sound but we need a stronger property known as a <em>proof of knowledge</em>. We will not define it formally, but roughly speaking it means we can transform any prover strategy that convinces the verifier that a statement is true with non-negligible probability into an algorithm that outputs the underlying secret (i.e., $x_1$ and $r_{com}$ in our case).  This is crucial in order to trasnform Alice&rsquo;s potentially malicious strategy into an honest but curious strategy.</p>
</li>
</ul>
<p>We can repeat this transformation for Bob (or Charlie, David, etc.. in the $k&gt;2$ party case) to transform a protocol secure in the honest but curious setting into a protocol secure (allowing for aborts) in the malicious setting.</p>
<h3 id="handling-probabilistic-strategies">Handling probabilistic strategies:
</h3><p>So far we assumed that the original strategy of Alice in the honest but curious is deterministic but of course we need to consider probabilistic strategies as well.
One approach could be to simply think of Alice&rsquo;s random tape $r$ as part of her secret input $x_1$.
However, while in the honest but curious setting Alice is still entitled to freely choose her own input $x_1$, she is not entitled to choose the random tape as she wishes but is supposed to follow the instructions of the protocol and choose it uniformly at random.
Hence we need to use a <em>coin tossing protocol</em> to choose the randomness, or more accurately what&rsquo;s known as a &ldquo;coin tossing in the well&rdquo; protocol where Alice and Bob engage in a coin tossing protocol at the end of which they generate some random coins $r$ that only Alice knows but Bob is still guaranteed that they are random.
Such a protocol can actually be achieved very simply.
Suppose we want to generate $m$ coins:</p>
<ul>
<li>Alice selects $r&rsquo;\leftarrow_R{0,1}^m$ at random and engages in a <em>commitment protocol</em> to commit to $r&rsquo;$.</li>
<li>Bob selects $r&rsquo;&rsquo; \leftarrow_R{0,1}^m$ and sends it to Alice in the clear.</li>
<li>The result of the coin tossing protocol will be the string $r=r&rsquo;\oplus r&rsquo;&rsquo;$.</li>
</ul>
<p>Note that Alice knows $r$.
Bob doesn&rsquo;t know $r$ but because he chose $r&rsquo;&rsquo;$ <em>after</em> Alice committed to $r&rsquo;$ he knows that it must be fully random regardless of Alice&rsquo;s choice of $r&rsquo;$.
It can be shown that if we use this coin tossing protocol at the beginning and then modify the zero knowledge proofs to show that $m_i=f_i(x_1,r_1,m_1,\ldots,m_{i-1})$ where $r_1$ is the string that is consistent with the transcript of the coin tossing protocol, then we get a general transformation of an honest but curious adversary into the malicious setting.</p>
<p>The notion of multiparty secure computation - defining it and achieving it - is quite subtle and I do urge you to read some of the other references listed above as well.
In particular, the slides and videos from the <a class="link" href="https://cyber.biu.ac.il/event/the-1st-biu-winter-school/"  target="_blank" rel="noopener"
    >Bar Ilan winter school on secure computation and efficiency</a>, as well as the ones from the <a class="link" href="https://cyber.biu.ac.il/event/the-5th-biu-winter-school/"  target="_blank" rel="noopener"
    >winter school on advances in practical multiparty computation</a> are great sources for this and related materials.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Unlike much of this text, in the context of multiparty secure computation we use $k$ to denote the number of parties in the protocol, as opposed to a the secret key of some encryption scheme.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Protocols for $k&gt;2$ parties require also a <em>broadcast channel</em> but this  can be <a class="link" href="http://epubs.siam.org/doi/abs/10.1137/0212045?journalCode=smjcat"  target="_blank" rel="noopener"
    >implemented</a> using the combination of authenticated channels and digital signatures.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Fixing the input and output sizes to $n$ is done for notational simplicity and is without loss of generality. More generally, the inputs and outputs could have sizes up to polynomial in $n$ and some inputs or output can also be empty. Also, note that one can define a more general notion of stateful functionalities, though it is not hard to reduce the task of building a protocol for stateful functionalities to building protocols for stateless ones.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>As a side note, we can avoid this issue if we have an <em>honest majority</em> of players - i.e. if $|T|&lt;k/2$, but this condition does not make sense in  the two party setting, where you can only have an honest majority if there is no cheating party.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>Actually, if we want to be pedantic, this is what&rsquo;s known as a zero knowledge <em>argument</em> system since soundness is only guaranteed against efficient provers. However, this distinction is not important in almost all applications.&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p>Our treatment of the input graph $H$ is an instance of a general case. While the definition of a functionality only talks about private inputs, it&rsquo;s very easy to include public inputs as well. If we want to include some public input $Z$ we can simply have $Z$ concatenated to all the private inputs (and the functionality check that they are all the same, otherwise outputting <code>error</code> or some similar result).&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p>Originally this was shown under the assumption of trapdoor permutations (which can be derived from the Factoring or RSA conjectures) but it is known today under a variety of other assumptions, including in particular the LWE conjecture.&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8">
<p>One example of the kind of issues that can arise is the &ldquo;grandmasters attack&rdquo; whereby someone with no knowledge of chess could play two grandmasters simultaneously, relaying their moves to one another and thereby guaranteeing a win in at least one of the games (or a draw in both).&#160;<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9">
<p>As we discussed before, bitcoin doesn&rsquo;t have the notion of accounts but rather what we mean by that for each one of the public keys, the public ledger contains a sufficiently large amount of bitcoins that have been transferred to these keys (in the sense that whomever can sign w.r.t. these keys can transfer the corresponding coins).&#160;<a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:10">
<p>Note that even though we assumed that in the original honest-but-curious protocol Alice used a deterministic strategy, we will transform the protocol into one in which Alice uses a randomized strategy in both the commitment and zero knowledge phases.&#160;<a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 Example Person
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.26.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
